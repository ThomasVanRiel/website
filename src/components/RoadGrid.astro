---
import RoadLabel from './RoadLabel.astro';

type Props = {
  images: Array<{
    src: string
    alt: string
    name: string
    cx: number
    cy: number
    radius: number
    filters: Array<{ closedFraction: number }>
    sorters: Array<{ 
      radius: number
      rmsError: number
      rmsErrorNorm: number
      distanceToCityCenter: number
      city: string
      roadId: string
    }>
  }>
  columns?: 2 | 3 | 4 | 5 | 6
  gap?: "sm" | "md" | "lg"
}

const { 
  images, 
  columns = 3, 
  gap = "md"
} = Astro.props

const gapSizes = {
  sm: 8,
  md: 16,
  lg: 24
}

const gapPx = gapSizes[gap]
---

<div class="isotope-controls mb-6 space-y-4">
  <div class="flex flex-wrap gap-4">
    <!-- Filter Controls -->
    <div class="flex-1 min-w-[200px]">
      <label class="block text-sm font-medium mb-2">
        Min. <span id="closedFractionValue" class="font-semibold">80%</span> closed. <span class="italic">(showing <span id="visibleCount">0</span>/<span id="totalCount">0</span>)</span>
      </label>
      <input 
        type="range" 
        id="closed-fraction-slider" 
        min="0" 
        max="100" 
        value="80" 
        step="5"
        class="w-full h-2 bg-neutral-200 dark:bg-neutral-700 rounded-lg appearance-none cursor-pointer accent-neutral-900 dark:accent-neutral-100"
      />
    </div>

    <!-- Sort Controls -->
    <div class="flex-1 min-w-[200px]">
      <label class="block text-sm font-medium mb-2">Sort By</label>
      <select 
        id="sort-select" 
        class="w-full px-3 py-2 border border-neutral-300 dark:border-neutral-700 rounded-lg bg-white dark:bg-neutral-900"
      >
        <option value="original-order">Road index (R#)</option>
        <option value="name">City</option>
        <option value="radius">Radius</option>
        <option value="rms-error" selected>RMS Error</option>
        <option value="rms-error-norm">RMS Error (Normalized)</option>
        <option value="distance-to-city-center">Distance to City Center</option>
        <option value="closed-fraction">Closed Fraction</option>
      </select>
    </div>

    <!-- Sort Order Controls -->
    <div class="flex-1 min-w-[200px]">
      <label class="block text-sm font-medium mb-2">Sort Order</label>
      <select 
        id="order-select" 
        class="w-full px-3 py-2 border border-neutral-300 dark:border-neutral-700 rounded-lg bg-white dark:bg-neutral-900"
      >
        <option value="asc">Ascending</option>
        <option value="desc">Descending</option>
      </select>
    </div>
  </div>
</div>

<div 
  class="isotope-grid w-full" 
  data-columns={columns}
  data-gap={gapPx}
>
  {images.map((image) => (
    <div 
      class="grid-item relative overflow-hidden"
      data-closed-fraction={image.filters[0]?.closedFraction}
      data-radius={image.sorters[0]?.radius}
      data-rms-error={image.sorters[0]?.rmsError}
      data-rms-error-norm={image.sorters[0]?.rmsErrorNorm}
      data-distance-to-city-center={image.sorters[0]?.distanceToCityCenter}
      data-city={image.sorters[0]?.city}
      data-road-id={image.sorters[0]?.roadId}
    >
      <div class="px-3 py-0">
        <h3 class="text-sm font-medium font-semibold text-center">
          {image.sorters[0]?.city || 'Unknown City'}&nbsp;
          <RoadLabel 
            label={image.sorters[0]?.roadId.charAt(0) || 'R'} 
            number={image.sorters[0]?.roadId.slice(1) || ''}
          />
        </h3>
      </div>
      <div class="relative aspect-square">
        <img 
          src={image.src} 
          alt={image.alt}
          class="absolute inset-0 w-full h-full object-cover py-0"
        />
        <svg class="absolute inset-0 w-full h-full pointer-events-none" viewBox={`0 0 800 800`} xmlns="http://www.w3.org/2000/svg">
          <circle cx={image.cx.toFixed(0)} cy={image.cy.toFixed(0)} r={image.radius.toFixed(0)} fill="none" stroke="black" stroke-width="5" stroke-dasharray="10,10" class="dark:stroke-white" />
          <circle cx={image.cx.toFixed(0)} cy={image.cy.toFixed(0)} r="5" fill="black" stroke="none" class="dark:fill-white dark:stroke-white" />
        </svg>
      </div>
      <div class="px-3 py-0">
        <p class="text-xs text-center">
          Error: <span class="font-semibold">{image.sorters[0]?.rmsError?.toFixed(0) || 'N/A'} m</span> ({(image.sorters[0]?.rmsErrorNorm * 100).toFixed(2) || 'N/A'}%)<br/>
          Radius: <span class="font-semibold">{image.sorters[0]?.radius?.toFixed(0) || 'N/A'} m</span> <br/>
          Center offset: <span class="font-semibold">{image.sorters[0]?.distanceToCityCenter ? (image.sorters[0].distanceToCityCenter / 1000).toFixed(2) : 'N/A'} km</span> <br/>
          <span class="font-semibold">{(image.filters[0]?.closedFraction * 100).toFixed(0) || 'N/A'}%</span> closed
        </p>
      </div>
    </div>
  ))}
</div>

<script>
  import Isotope from 'isotope-layout';

  let isotopeInstances: Isotope[] = [];
  let controlsBound = false;
  let currentThreshold = 0.0; // keep slider/filter in sync (80%)
  let currentSortBy: string = 'original-order';
  let currentSortAscending = true;

  function getResponsiveColumns(): number {
    const width = window.innerWidth;
    if (width < 768) return 3;      // md
    return 4;                        // 2xl+
  }

  function applyGridSizing() {
    const columns = getResponsiveColumns();
    const grids = document.querySelectorAll('.isotope-grid');

    grids.forEach((gridElement) => {
      const grid = gridElement as HTMLElement;
      const gap = parseInt(grid.dataset.gap || '16');
      const columnWidth = `calc((100% - ${gap * (columns - 1)}px) / ${columns})`;

      const items = grid.querySelectorAll('.grid-item');
      items.forEach((item) => {
        const el = item as HTMLElement;
        el.style.width = columnWidth;
        el.style.marginBottom = `${gap}px`;
      });
    });
  }

  function filterPredicate(threshold: number) {
    return (itemElem: Element) => {
      const closedFraction = parseFloat((itemElem as HTMLElement).dataset.closedFraction || '0');
      return closedFraction >= threshold;
    };
  }

  function applyStateToInstances() {
    isotopeInstances.forEach(iso => {
      iso.arrange({
        filter: filterPredicate(currentThreshold),
        sortBy: currentSortBy,
        sortAscending: currentSortAscending
      });
    });

    updateCounts(currentThreshold);
  }

  function initIsotope() {
    const grids = document.querySelectorAll('.isotope-grid');

    isotopeInstances.forEach(iso => iso.destroy());
    isotopeInstances = [];

    applyGridSizing();

    grids.forEach((gridElement) => {
      const grid = gridElement as HTMLElement;
      const gap = parseInt(grid.dataset.gap || '16');

      const iso = new Isotope(grid, {
        itemSelector: '.grid-item',
        layoutMode: 'fitRows',
        fitRows: {
          gutter: gap
        },
        transitionDuration: '0.3s',
        percentPosition: false,
        getSortData: {
          name: (itemElem: Element) => {
            const nameEl = itemElem.querySelector('h3');
            return nameEl?.textContent?.toLowerCase() || '';
          },
          radius: '[data-radius] parseFloat',
          'rms-error': '[data-rms-error] parseFloat',
          'rms-error-norm': '[data-rms-error-norm] parseFloat',
          'distance-to-city-center': '[data-distance-to-city-center] parseFloat',
          'closed-fraction': '[data-closed-fraction] parseFloat'
        },
        filter: filterPredicate(currentThreshold),
        sortBy: currentSortBy,
        sortAscending: currentSortAscending
      });

      isotopeInstances.push(iso);
    });

    setupControls();
    updateCounts(currentThreshold);
  }

  function updateCounts(threshold: number) {
    const visibleCountEl = document.getElementById('visibleCount') as HTMLSpanElement;
    const totalCountEl = document.getElementById('totalCount') as HTMLSpanElement;

    if (visibleCountEl && totalCountEl) {
      const grids = document.querySelectorAll('.isotope-grid');
      let visibleCount = 0;
      let totalCount = 0;

      grids.forEach(grid => {
        const allItems = grid.querySelectorAll('.grid-item');
        totalCount += allItems.length;

        allItems.forEach(item => {
          const closedFraction = parseFloat((item as HTMLElement).dataset.closedFraction || '0');
          if (closedFraction >= threshold) {
            visibleCount++;
          }
        });
      });

      visibleCountEl.textContent = visibleCount.toString();
      totalCountEl.textContent = totalCount.toString();
    }
  }

  function setupControls() {
    if (controlsBound) return;

    const closedFractionSlider = document.getElementById('closed-fraction-slider') as HTMLInputElement;
    const closedFractionValue = document.getElementById('closedFractionValue') as HTMLSpanElement;
    const sortSelect = document.getElementById('sort-select') as HTMLSelectElement;
    const orderSelect = document.getElementById('order-select') as HTMLSelectElement;

    if (!closedFractionSlider || !sortSelect || !orderSelect || !closedFractionValue) return;

    controlsBound = true;

    // Sync UI with current state
    closedFractionSlider.value = String(Math.round(currentThreshold * 100));
    closedFractionValue.textContent = `${closedFractionSlider.value}%`;
    sortSelect.value = currentSortBy;
    orderSelect.value = currentSortAscending ? 'asc' : 'desc';

    closedFractionSlider.addEventListener('input', () => {
      currentThreshold = parseFloat(closedFractionSlider.value) / 100;
      closedFractionValue.textContent = `${closedFractionSlider.value}%`;
      applyStateToInstances();
    });

    const applySorting = () => {
      currentSortBy = sortSelect.value;
      currentSortAscending = orderSelect.value !== 'desc';
      applyStateToInstances();
    };

    sortSelect.addEventListener('change', applySorting);
    orderSelect.addEventListener('change', applySorting);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initIsotope);
  } else {
    initIsotope();
  }

  document.addEventListener('astro:page-load', initIsotope);

  let resizeTimeout: number;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = window.setTimeout(() => {
      applyGridSizing();
      isotopeInstances.forEach(iso => iso.layout());
    }, 250);
  });
</script>
