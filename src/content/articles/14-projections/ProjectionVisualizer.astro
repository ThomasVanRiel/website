---
// ProjectionVisualizer.astro - 2D map projection visualizer with animated transitions
---

<div class="projection-visualizer">
  <div class="canvas-container">
    <canvas id="globe-canvas"></canvas>
  </div>
  <div class="controls" id="projection-controls">
    <!-- Buttons generated dynamically by category -->
  </div>
</div>

<style>
  .projection-visualizer {
    width: 100%;
  }

  .canvas-container {
    width: 100%;
    height: 600px;
    max-height: 80vh;
    position: relative;
    border-radius: 8px;
    overflow: hidden;
  }

  @media (max-width: 768px) {
    .canvas-container {
      height: 400px;
    }
  }

  @media (max-width: 480px) {
    .canvas-container {
      height: 300px;
    }
  }

  #globe-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  #globe-canvas.projection-mode {
    cursor: default;
  }

  .controls {
    margin-top: 20px;
  }

  .category-group {
    margin-bottom: 15px;
  }

  .category-label {
    font-weight: 600;
    margin-bottom: 8px;
    font-size: 14px;
  }

  .category-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .btn {
    padding: 10px 20px;
    backdrop-filter: blur(10px);
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.3s ease;
  }

  .btn:active {
    transform: scale(0.95);
  }

  .btn-active {
    background: rgba(0, 0, 0, 0.15) !important;
    font-weight: 600;
  }
</style>

<script>
  import * as d3 from 'd3';
  import { projections, getProjectionById, type DataPoint, type ProjectionConfig } from './projections';

  // Theme detection
  const isDarkTheme = () => document.documentElement.classList.contains('dark');
  
  const getThemeColors = () => {
    const dark = isDarkTheme();
    return {
      // Data point colors
      water: '#3b82f6',      // Blue for water points (same in both themes)
      land: dark ? '#fff' : '#000',  // Lighter green in dark mode
      pointOpacity: 0.7,
      pointRadius: 2.5,
      
      // Display options
      showWaterPoints: false,
      
      // UI Controls
      buttonBg: dark ? 'rgba(255, 255, 255, 0.08)' : 'rgba(0, 0, 0, 0.05)',
      buttonBgHover: dark ? 'rgba(255, 255, 255, 0.12)' : 'rgba(0, 0, 0, 0.1)',
      buttonBorder: dark ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.15)',
      buttonBorderHover: dark ? 'rgba(255, 255, 255, 0.25)' : 'rgba(0, 0, 0, 0.25)',
      buttonText: dark ? '#f3f4f6' : '#333',
    };
  };

  // ===== CONFIGURATION =====
  let CONFIG = getThemeColors();
  // ========================

  // State
  let currentProjectionId: string = projections[0].id;
  let gridData: DataPoint[] = [];
  let canvas: HTMLCanvasElement;
  let ctx: CanvasRenderingContext2D;
  let width: number;
  let height: number;
  let projection: d3.GeoProjection;
  let path: d3.GeoPath;
  let rotation: [number, number, number] = [0, -30, 0]; // Greenwich, tilted up 50° latitude
  let animationFrameId: number | null = null;
  let graticuleOpacity: number = 0;
  let graticule: d3.GeoGeometryObjects;
  
  // Cache projected coordinates for performance
  interface ProjectedPoint {
    x: number;
    y: number;
    visible: boolean;
    alpha: number;
    type: number;
    color?: string;
  }
  let projectedPoints: ProjectedPoint[] = [];

  // Generate projection buttons organized by category
  function generateButtons() {
    const controlsContainer = document.getElementById('projection-controls');
    if (!controlsContainer) return;

    // Group projections by category
    const categories = new Map<string, ProjectionConfig[]>();
    projections.forEach(proj => {
      if (!categories.has(proj.category)) {
        categories.set(proj.category, []);
      }
      categories.get(proj.category)!.push(proj);
    });

    let isFirstButton = true;

    // Create category groups
    categories.forEach((projs, category) => {
      const categoryGroup = document.createElement('div');
      categoryGroup.className = 'category-group';

      const categoryLabel = document.createElement('div');
      categoryLabel.className = 'category-label';
      categoryLabel.textContent = category;
      categoryGroup.appendChild(categoryLabel);

      const buttonsContainer = document.createElement('div');
      buttonsContainer.className = 'category-buttons';

      projs.forEach(proj => {
        const button = document.createElement('button');
        button.id = `btn-${proj.id}`;
        button.className = isFirstButton ? 'btn btn-active' : 'btn';
        button.textContent = proj.label;
        button.addEventListener('click', () => switchToProjection(proj.id));
        buttonsContainer.appendChild(button);
        isFirstButton = false;
      });

      categoryGroup.appendChild(buttonsContainer);
      controlsContainer.appendChild(categoryGroup);
    });
  }

  // Initialize
  async function init() {
    const container = document.querySelector('.canvas-container');
    if (!container) return;

    canvas = document.getElementById('globe-canvas') as HTMLCanvasElement;
    if (!canvas) return;
    
    ctx = canvas.getContext('2d', { alpha: true })!;

    const rect = container.getBoundingClientRect();
    width = rect.width;
    height = rect.height;
    
    // Set canvas size with device pixel ratio for sharp rendering
    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    ctx.scale(dpr, dpr);

    // Generate projection buttons
    generateButtons();

    // Apply button styles and hover handlers
    applyButtonStyles();
    const buttons = document.querySelectorAll('.btn');
    buttons.forEach(btn => {
      btn.addEventListener('mouseenter', () => {
        (btn as HTMLElement).style.background = CONFIG.buttonBgHover;
        (btn as HTMLElement).style.borderColor = CONFIG.buttonBorderHover;
      });
      btn.addEventListener('mouseleave', () => {
        (btn as HTMLElement).style.background = CONFIG.buttonBg;
        (btn as HTMLElement).style.borderColor = CONFIG.buttonBorder;
      });
    });

    // Load data
    await loadGridData();

    // Setup initial projection
    setupProjection(currentProjectionId);

    // Render initial view
    graticuleOpacity = 1;
    render();

    // Setup event listeners
    setupEventListeners();
  }

  async function loadGridData() {
    try {
      const response = await fetch('/data/land_water_uniform_24000samples_ne1_color_land_only.json');
      const data = await response.json();

      gridData = Object.entries(data).map(([key, value]: [string, any]) => {
        const [lon, lat] = key.split(',').map(Number);
        return { 
          lon, 
          lat, 
          type: value.type as number,
          color: value.color as [number, number, number] | undefined
        };
      });
    } catch (error) {
      console.error('Failed to load grid data:', error);
      // Fallback: create sample data
      gridData = [];
      for (let lon = -180; lon < 180; lon += 5) {
        for (let lat = -90; lat < 90; lat += 5) {
          gridData.push({ lon, lat, type: Math.random() > 0.5 ? 1 : 0 });
        }
      }
    }
  }

  function setupProjection(projectionId: string) {
    const projConfig = getProjectionById(projectionId);
    if (!projConfig) return;

    projection = projConfig.setup(
      width,
      height,
      rotation,
      gridData,
      CONFIG.showWaterPoints
    );

    path = d3.geoPath().projection(projection);
    graticule = d3.geoGraticule()();
    projectPoints();
  }

  // Returns 0–1 alpha based on angular distance from clip edge (for globe projections)
  function getClipAlpha(lon: number, lat: number, proj: d3.GeoProjection): number {
    const clipAngle = (proj as any).clipAngle?.();
    if (clipAngle == null) return 1;

    const rot = proj.rotate();
    const cLon = -rot[0];
    const cLat = -rot[1];
    const toRad = Math.PI / 180;
    const cosD =
      Math.sin(cLat * toRad) * Math.sin(lat * toRad) +
      Math.cos(cLat * toRad) * Math.cos(lat * toRad) * Math.cos((lon - cLon) * toRad);
    const distance = Math.acos(Math.min(1, Math.max(-1, cosD))) / toRad;

    const fadeMargin = 10;
    if (distance <= clipAngle - fadeMargin) return 1;
    if (distance >= clipAngle) return 0;
    return (clipAngle - distance) / fadeMargin;
  }

  function projectPoints() {
    const isGlobe = getProjectionById(currentProjectionId)?.isGlobe ?? false;
    projectedPoints = gridData.map(d => {
      const coords = projection([d.lon, d.lat]);
      const alpha = isGlobe ? getClipAlpha(d.lon, d.lat, projection) : 1;
      const color = d.color
        ? `rgb(${Math.round(d.color[0] * 255)}, ${Math.round(d.color[1] * 255)}, ${Math.round(d.color[2] * 255)})`
        : undefined;
      return {
        x: coords?.[0] ?? -9999,
        y: coords?.[1] ?? -9999,
        visible: alpha > 0 && coords != null && isFinite(coords[0]) && isFinite(coords[1]),
        alpha,
        type: d.type,
        color
      };
    });
  }

  function render() {
    if (!ctx) return;
    
    // Clear canvas (transparent)
    ctx.clearRect(0, 0, width, height);
    
    const projConfig = getProjectionById(currentProjectionId);

    // Draw graticule/background
    if (graticuleOpacity > 0) {
      if (projConfig && !projConfig.isGlobe) {
        ctx.save();
        ctx.globalAlpha = graticuleOpacity;
        ctx.beginPath();
        path.context(ctx)({type: 'Sphere'});
        ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
        ctx.fill();
        ctx.restore();
      }
      
      ctx.save();
      ctx.globalAlpha = graticuleOpacity;
      ctx.beginPath();
      path.context(ctx)(graticule);
      ctx.strokeStyle = isDarkTheme() ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.15)';
      ctx.lineWidth = 0.5;
      ctx.stroke();
      ctx.restore();
    }
    
    // Draw points
    const filteredIndices = CONFIG.showWaterPoints 
      ? projectedPoints.map((_, i) => i)
      : projectedPoints.map((p, i) => p.type !== 0 ? i : -1).filter(i => i >= 0);
    
    filteredIndices.forEach(i => {
      const p = projectedPoints[i];
      if (!p.visible) return;
      
      // Use color if available, otherwise fall back to default colors
      ctx.fillStyle = p.color || (p.type === 0 ? CONFIG.water : CONFIG.land);
      ctx.globalAlpha = CONFIG.pointOpacity * p.alpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, CONFIG.pointRadius, 0, Math.PI * 2);
      ctx.fill();
    });

    ctx.globalAlpha = 1;
  }

  function switchToProjection(newProjectionId: string) {
    if (newProjectionId === currentProjectionId) return;
    
    currentProjectionId = newProjectionId;
    
    // Update button states
    document.querySelectorAll('.btn').forEach(btn => {
      btn.classList.remove('btn-active');
    });
    document.getElementById(`btn-${newProjectionId}`)?.classList.add('btn-active');
    
    const canvasEl = document.getElementById('globe-canvas');
    const projConfig = getProjectionById(newProjectionId);
    if (canvasEl && projConfig) {
      canvasEl.classList.toggle('projection-mode', !projConfig.isGlobe);
    }

    // Animate transition
    animateTransition();
  }

  function animateTransition() {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }

    // Save old state
    const oldPath = path;
    const oldPoints = [...projectedPoints];

    // Setup new projection
    setupProjection(currentProjectionId);
    const newProjection = projection;
    const newPath = path;
    const projConfig = getProjectionById(currentProjectionId);

    // Calculate new projected points
    const isGlobe = projConfig?.isGlobe ?? false;
    const newPoints = gridData.map(d => {
      const coords = newProjection([d.lon, d.lat]);
      const alpha = isGlobe ? getClipAlpha(d.lon, d.lat, newProjection) : 1;
      const color = d.color
        ? `rgb(${Math.round(d.color[0] * 255)}, ${Math.round(d.color[1] * 255)}, ${Math.round(d.color[2] * 255)})`
        : undefined;
      return {
        x: coords?.[0] ?? -9999,
        y: coords?.[1] ?? -9999,
        visible: alpha > 0 && coords != null && isFinite(coords[0]) && isFinite(coords[1]),
        alpha,
        type: d.type,
        color
      };
    });

    const duration = 1000;
    const startTime = performance.now();

    function animate() {
      const elapsed = performance.now() - startTime;
      const t = Math.min(elapsed / duration, 1);
      const eased = d3.easeQuadInOut(t);

      ctx.clearRect(0, 0, width, height);

      // Sphere fill: crossfade between old and new outlines
      if (projConfig && !projConfig.isGlobe) {
        if (eased < 1) {
          ctx.save();
          ctx.globalAlpha = 1 - eased;
          ctx.beginPath();
          oldPath.context(ctx)({type: 'Sphere'});
          ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
          ctx.fill();
          ctx.restore();
        }
        if (eased > 0) {
          ctx.save();
          ctx.globalAlpha = eased;
          ctx.beginPath();
          newPath.context(ctx)({type: 'Sphere'});
          ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
          ctx.fill();
          ctx.restore();
        }
      }

      // Graticule: crossfade
      const gratStroke = isDarkTheme() ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.15)';
      if (eased < 1) {
        ctx.save();
        ctx.globalAlpha = 1 - eased;
        ctx.beginPath();
        oldPath.context(ctx)(graticule);
        ctx.strokeStyle = gratStroke;
        ctx.lineWidth = 0.5;
        ctx.stroke();
        ctx.restore();
      }
      if (eased > 0) {
        ctx.save();
        ctx.globalAlpha = eased;
        ctx.beginPath();
        newPath.context(ctx)(graticule);
        ctx.strokeStyle = gratStroke;
        ctx.lineWidth = 0.5;
        ctx.stroke();
        ctx.restore();
      }

      // Points: interpolate positions and alpha
      projectedPoints = oldPoints.map((old, i) => {
        const target = newPoints[i];
        const alpha = old.alpha + (target.alpha - old.alpha) * eased;
        return {
          x: old.x + (target.x - old.x) * eased,
          y: old.y + (target.y - old.y) * eased,
          visible: alpha > 0 && (old.visible || target.visible),
          alpha,
          type: target.type,
          color: target.color
        };
      });

      // Draw points
      const filteredIndices = CONFIG.showWaterPoints
        ? projectedPoints.map((_: any, i: number) => i)
        : projectedPoints.map((p: any, i: number) => p.type !== 0 ? i : -1).filter((i: number) => i >= 0);

      filteredIndices.forEach((i: number) => {
        const p = projectedPoints[i];
        if (!p.visible) return;
        ctx.fillStyle = p.color || (p.type === 0 ? CONFIG.water : CONFIG.land);
        ctx.globalAlpha = CONFIG.pointOpacity * p.alpha;
        ctx.beginPath();
        ctx.arc(p.x, p.y, CONFIG.pointRadius, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.globalAlpha = 1;

      if (t < 1) {
        animationFrameId = requestAnimationFrame(animate);
      } else {
        projectedPoints = newPoints;
        graticuleOpacity = 1;
        animationFrameId = null;
        render(); // Final clean render
      }
    }

    animate();
  }


  function setupEventListeners() {

    // Window resize
    let resizeTimer: number;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = window.setTimeout(() => {
        const container = document.querySelector('.canvas-container');
        if (!container) return;

        const rect = container.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        
        // Update canvas size with device pixel ratio
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        ctx.scale(dpr, dpr);

        setupProjection(currentProjectionId);
        render();
      }, 150);
    });

    // Theme change observer
    const observer = new MutationObserver(() => {
      CONFIG = getThemeColors();
      applyButtonStyles();
      render();
    });
    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class']
    });
  }

  function applyButtonStyles() {
    const buttons = document.querySelectorAll('.btn');
    buttons.forEach(btn => {
      (btn as HTMLElement).style.background = CONFIG.buttonBg;
      (btn as HTMLElement).style.border = `1px solid ${CONFIG.buttonBorder}`;
      (btn as HTMLElement).style.color = CONFIG.buttonText;
    });
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>
