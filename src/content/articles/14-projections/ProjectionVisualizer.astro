---
// ProjectionVisualizer.astro - 2D map projection visualizer with animated transitions
---

<div class="projection-visualizer">
  <div class="canvas-container">
    <canvas id="globe-canvas"></canvas>
  </div>
  <div class="projection-controls" id="projection-controls">
    <!-- Projection list generated dynamically by category -->
  </div>
</div>

<style>
  .projection-visualizer {
    width: 100%;
    display: flex;
    gap: 20px;
    align-items: flex-start;
  }

  .canvas-container {
    flex: 1;
    min-width: 0;
    aspect-ratio: 1;
    max-height: 80vh;
    max-width: 80vh;
    position: relative;
    border-radius: 8px;
    overflow: hidden;
  }

  @media (max-width: 768px) {
    .projection-visualizer {
      gap: 12px;
    }
    
    .canvas-container {
      max-width: calc(100% - 150px);
    }
  }

  @media (max-width: 480px) {
    .projection-visualizer {
      gap: 8px;
    }
    
    .canvas-container {
      max-width: calc(100% - 120px);
    }
  }

  #globe-canvas {
    width: 100%;
    height: 100%;
    display: block;
    position: relative;
    z-index: 1;
  }

  #globe-canvas.projection-mode {
    cursor: default;
  }

  .projection-controls {
    flex-shrink: 0;
    width: 200px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    overflow-y: auto;
    overflow-x: visible;
    padding: 8px 12px;
    border-radius: 8px;
    /* background-color: rgba(0, 0, 0, 0.02); */
    
    /* Fade effect for overflowing content */
    mask-image: linear-gradient(to bottom, 
      transparent 0%, 
      black 3%, 
      black 97%, 
      transparent 100%);
    -webkit-mask-image: linear-gradient(to bottom, 
      transparent 0%, 
      black 3%, 
      black 97%, 
      transparent 100%);
    
    /* Visible scrollbar styling */
    scrollbar-width: thin;
    scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
  }

  :global(.dark) .projection-controls {
    background-color: rgba(255, 255, 255, 0.03);
  }

  .projection-controls::-webkit-scrollbar {
    width: 6px;
  }

  .projection-controls::-webkit-scrollbar-track {
    background: transparent;
  }

  .projection-controls::-webkit-scrollbar-thumb {
    background-color: rgba(156, 163, 175, 0.5);
    border-radius: 3px;
  }

  .projection-controls::-webkit-scrollbar-thumb:hover {
    background-color: rgba(156, 163, 175, 0.7);
  }

  @media (max-width: 768px) {
    .projection-controls {
      width: 140px;
      padding: 6px 8px;
    }
  }

  @media (max-width: 480px) {
    .projection-controls {
      width: 110px;
      padding: 4px 6px;
    }
  }

  /* Dynamically generated elements need global styles in Astro */
  .projection-controls :global(.category-group) {
    display: flex;
    flex-direction: column;
  }

  .projection-controls :global(.category-label) {
    font-weight: 700;
    font-size: 13px;
    text-align: left;
    padding: 4px 0;
    color: var(--tw-prose-body);
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 6px;
  }

  .projection-controls :global(.category-label:hover) {
    opacity: 0.8;
  }

  .projection-controls :global(.category-arrow) {
    font-size: 8px;
    transition: transform 0.2s ease;
    display: inline-block;
    opacity: 0.4;
    font-weight: 400;
  }

  .projection-controls :global(.category-arrow.collapsed) {
    transform: rotate(-90deg);
  }

  .projection-controls :global(.category-items) {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    margin-left: 12px;
    transition: max-height 0.3s ease, opacity 0.2s ease;
    max-height: 1000px;
    opacity: 1;
    overflow: hidden;
  }

  .projection-controls :global(.category-items.collapsed) {
    max-height: 0;
    opacity: 0;
  }

  .projection-controls :global(.proj-item) {
    padding: 2px 0;
    cursor: pointer;
    font-size: 12px;
    transition: opacity 0.2s ease;
    opacity: 0.5;
    background: none;
    border: none;
    text-align: left;
    white-space: nowrap;
    font-family: inherit;
    font-weight: 400;
    color: var(--tw-prose-body);
  }

  .projection-controls :global(.proj-item:hover) {
    opacity: 1;
  }

  .projection-controls :global(.proj-item-active) {
    opacity: 1;
    font-weight: 500;
  }

  @media (max-width: 768px) {
    .projection-controls :global(.category-label) {
      font-size: 11px;
    }

    .projection-controls :global(.proj-item) {
      font-size: 10px;
    }
  }

  @media (max-width: 480px) {
    .projection-controls :global(.category-label) {
      font-size: 10px;
    }

    .projection-controls :global(.proj-item) {
      font-size: 9px;
    }
  }
</style>

<script>
  import * as d3 from 'd3';
  import { projections, getProjectionById, type DataPoint, type ProjectionConfig } from './projections';

  // Theme detection
  const isDarkTheme = () => document.documentElement.classList.contains('dark');
  
  const getThemeColors = () => {
    const dark = isDarkTheme();
    return {
      // Data point colors
      water: '#3b82f6',      // Blue for water points (same in both themes)
      land: dark ? '#fff' : '#000',  // Lighter green in dark mode
      pointOpacity: 0.7,
      
      // Display options
      showWaterPoints: false,
    };
  };

  // Calculate point radius based on canvas size
  const getPointRadius = (canvasWidth: number): number => {
    // Scale radius: ~2.5px at 600px width, ~4px at 1000px width
    return Math.max(1, Math.min(4, canvasWidth / 200));
  };

  // ===== CONFIGURATION =====
  let CONFIG = getThemeColors();
  let pointRadius: number = 2.5; // Will be updated based on canvas size
  // ========================

  // State
  let currentProjectionId: string = projections[0].id;
  let gridData: DataPoint[] = [];
  let canvas: HTMLCanvasElement;
  let ctx: CanvasRenderingContext2D;
  let width: number;
  let height: number;
  let projection: d3.GeoProjection;
  let path: d3.GeoPath;
  let rotation: [number, number, number] = [0, -30, 0]; // Greenwich, tilted up 50° latitude
  let animationFrameId: number | null = null;
  let graticuleOpacity: number = 0;
  let graticule: d3.GeoGeometryObjects;
  
  // Mouse interaction state
  let isDragging: boolean = false;
  let lastMouseX: number = 0;
  let lastMouseY: number = 0;
  
  // Cache projected coordinates for performance
  interface ProjectedPoint {
    x: number;
    y: number;
    visible: boolean;
    alpha: number;
    type: number;
    color?: string;
  }
  let projectedPoints: ProjectedPoint[] = [];

  // Generate projection list organized by category
  function generateButtons() {
    const controlsContainer = document.getElementById('projection-controls');
    if (!controlsContainer) return;

    // Group projections by category (excluding disabled ones)
    const categories = new Map<string, ProjectionConfig[]>();
    projections.filter(proj => !proj.disable).forEach(proj => {
      if (!categories.has(proj.category)) {
        categories.set(proj.category, []);
      }
      categories.get(proj.category)!.push(proj);
    });

    let isFirst = true;

    // Create category groups
    categories.forEach((projs, category) => {
      const categoryGroup = document.createElement('div');
      categoryGroup.className = 'category-group';

      const categoryLabel = document.createElement('div');
      categoryLabel.className = 'category-label';
      
      const arrow = document.createElement('span');
      arrow.className = 'category-arrow';
      arrow.textContent = '▼';
      
      const labelText = document.createElement('span');
      labelText.textContent = category;
      
      categoryLabel.appendChild(labelText);
      categoryLabel.appendChild(arrow);
      categoryGroup.appendChild(categoryLabel);

      const itemsContainer = document.createElement('div');
      itemsContainer.className = 'category-items';
      
      // Toggle category visibility on label click
      categoryLabel.addEventListener('click', () => {
        const isCollapsed = itemsContainer.classList.toggle('collapsed');
        arrow.classList.toggle('collapsed', isCollapsed);
      });

      projs.forEach(proj => {
        const item = document.createElement('button');
        item.id = `btn-${proj.id}`;
        item.className = isFirst ? 'proj-item proj-item-active' : 'proj-item';
        item.textContent = proj.label;
        item.addEventListener('click', () => switchToProjection(proj.id));
        itemsContainer.appendChild(item);
        isFirst = false;
      });

      categoryGroup.appendChild(itemsContainer);
      controlsContainer.appendChild(categoryGroup);
    });
  }

  // Initialize
  async function init() {
    const container = document.querySelector('.canvas-container');
    if (!container) return;

    canvas = document.getElementById('globe-canvas') as HTMLCanvasElement;
    if (!canvas) return;
    
    ctx = canvas.getContext('2d', { alpha: true })!;

    const rect = container.getBoundingClientRect();
    width = rect.width;
    height = rect.height;
    
    // Calculate point radius based on canvas size
    pointRadius = getPointRadius(width);
    
    // Set canvas size with device pixel ratio for sharp rendering
    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    ctx.scale(dpr, dpr);

    // Generate projection list
    generateButtons();

    // Load data
    await loadGridData();

    // Setup initial projection
    setupProjection(currentProjectionId);

    // Render initial view
    graticuleOpacity = 1;
    render();

    // Sync controls height with canvas
    syncControlsHeight();

    // Setup event listeners
    setupEventListeners();
  }

  async function loadGridData() {
    try {
      const response = await fetch('/data/land_water_uniform_24000samples_ne1_color_land_only.json');
      const data = await response.json();

      gridData = Object.entries(data).map(([key, value]: [string, any]) => {
        const [lon, lat] = key.split(',').map(Number);
        return { 
          lon, 
          lat, 
          type: value.type as number,
          color: value.color as [number, number, number] | undefined
        };
      });
    } catch (error) {
      console.error('Failed to load grid data:', error);
      // Fallback: create sample data
      gridData = [];
      for (let lon = -180; lon < 180; lon += 5) {
        for (let lat = -90; lat < 90; lat += 5) {
          gridData.push({ lon, lat, type: Math.random() > 0.5 ? 1 : 0 });
        }
      }
    }
  }

  function setupProjection(projectionId: string) {
    const projConfig = getProjectionById(projectionId);
    if (!projConfig) return;

    projection = projConfig.setup(
      width,
      height,
      rotation,
      gridData,
      CONFIG.showWaterPoints
    );

    path = d3.geoPath().projection(projection);
    graticule = d3.geoGraticule()();
    projectPoints();
  }

  // Returns 0–1 alpha based on angular distance from clip edge (for globe projections)
  function getClipAlpha(lon: number, lat: number, proj: d3.GeoProjection): number {
    const clipAngle = (proj as any).clipAngle?.();
    if (clipAngle == null) return 1;

    const rot = proj.rotate();
    const cLon = -rot[0];
    const cLat = -rot[1];
    const toRad = Math.PI / 180;
    const cosD =
      Math.sin(cLat * toRad) * Math.sin(lat * toRad) +
      Math.cos(cLat * toRad) * Math.cos(lat * toRad) * Math.cos((lon - cLon) * toRad);
    const distance = Math.acos(Math.min(1, Math.max(-1, cosD))) / toRad;

    const fadeMargin = 10;
    if (distance <= clipAngle - fadeMargin) return 1;
    if (distance >= clipAngle) return 0;
    return (clipAngle - distance) / fadeMargin;
  }

  function projectPoints() {
    const isGlobe = getProjectionById(currentProjectionId)?.isGlobe ?? false;
    projectedPoints = gridData.map(d => {
      const coords = projection([d.lon, d.lat]);
      const alpha = isGlobe ? getClipAlpha(d.lon, d.lat, projection) : 1;
      const color = d.color
        ? `rgb(${Math.round(d.color[0] * 255)}, ${Math.round(d.color[1] * 255)}, ${Math.round(d.color[2] * 255)})`
        : undefined;
      return {
        x: coords?.[0] ?? -9999,
        y: coords?.[1] ?? -9999,
        visible: alpha > 0 && coords != null && isFinite(coords[0]) && isFinite(coords[1]),
        alpha,
        type: d.type,
        color
      };
    });
  }

  function render() {
    if (!ctx) return;
    
    // Clear canvas (transparent)
    ctx.clearRect(0, 0, width, height);
    
    const projConfig = getProjectionById(currentProjectionId);

    // Draw graticule/background
    if (graticuleOpacity > 0) {
      if (projConfig) {
        ctx.save();
        ctx.globalAlpha = graticuleOpacity;
        ctx.beginPath();
        path.context(ctx)({type: 'Sphere'});
        ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
        ctx.fill();
        ctx.restore();
      }
      
      ctx.save();
      ctx.globalAlpha = graticuleOpacity;
      ctx.beginPath();
      path.context(ctx)(graticule);
      ctx.strokeStyle = isDarkTheme() ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.15)';
      ctx.lineWidth = 0.5;
      ctx.stroke();
      ctx.restore();
    }
    
    // Draw points
    const filteredIndices = CONFIG.showWaterPoints 
      ? projectedPoints.map((_, i) => i)
      : projectedPoints.map((p, i) => p.type !== 0 ? i : -1).filter(i => i >= 0);
    
    filteredIndices.forEach(i => {
      const p = projectedPoints[i];
      if (!p.visible) return;
      
      // Use color if available, otherwise fall back to default colors
      ctx.fillStyle = p.color || (p.type === 0 ? CONFIG.water : CONFIG.land);
      ctx.globalAlpha = CONFIG.pointOpacity * p.alpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, pointRadius, 0, Math.PI * 2);
      ctx.fill();
    });

    ctx.globalAlpha = 1;
  }

  function switchToProjection(newProjectionId: string) {
    if (newProjectionId === currentProjectionId) return;
    
    currentProjectionId = newProjectionId;
    
    // Update active states
    document.querySelectorAll('.proj-item').forEach(item => {
      item.classList.remove('proj-item-active');
    });
    document.getElementById(`btn-${newProjectionId}`)?.classList.add('proj-item-active');
    
    const canvasEl = document.getElementById('globe-canvas');
    const projConfig = getProjectionById(newProjectionId);
    if (canvasEl && projConfig) {
      canvasEl.classList.toggle('projection-mode', !projConfig.isGlobe);
      // Update cursor based on projection type
      canvasEl.style.cursor = projConfig.isGlobe ? 'grab' : 'default';
    }

    // Animate transition
    animateTransition();
  }

  function animateTransition() {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }

    // Save old state
    const oldPath = path;
    const oldPoints = [...projectedPoints];

    // Setup new projection
    setupProjection(currentProjectionId);
    const newProjection = projection;
    const newPath = path;
    const projConfig = getProjectionById(currentProjectionId);

    // Calculate new projected points
    const isGlobe = projConfig?.isGlobe ?? false;
    const newPoints = gridData.map(d => {
      const coords = newProjection([d.lon, d.lat]);
      const alpha = isGlobe ? getClipAlpha(d.lon, d.lat, newProjection) : 1;
      const color = d.color
        ? `rgb(${Math.round(d.color[0] * 255)}, ${Math.round(d.color[1] * 255)}, ${Math.round(d.color[2] * 255)})`
        : undefined;
      return {
        x: coords?.[0] ?? -9999,
        y: coords?.[1] ?? -9999,
        visible: alpha > 0 && coords != null && isFinite(coords[0]) && isFinite(coords[1]),
        alpha,
        type: d.type,
        color
      };
    });

    const duration = 1000;
    const startTime = performance.now();

    function animate() {
      const elapsed = performance.now() - startTime;
      const t = Math.min(elapsed / duration, 1);
      const eased = d3.easeQuadInOut(t);

      ctx.clearRect(0, 0, width, height);

      // Sphere fill: crossfade between old and new outlines
      if (projConfig) {
        if (eased < 1) {
          ctx.save();
          ctx.globalAlpha = 1 - eased;
          ctx.beginPath();
          oldPath.context(ctx)({type: 'Sphere'});
          ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
          ctx.fill();
          ctx.restore();
        }
        if (eased > 0) {
          ctx.save();
          ctx.globalAlpha = eased;
          ctx.beginPath();
          newPath.context(ctx)({type: 'Sphere'});
          ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
          ctx.fill();
          ctx.restore();
        }
      }

      // Graticule: crossfade
      const gratStroke = isDarkTheme() ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.15)';
      if (eased < 1) {
        ctx.save();
        ctx.globalAlpha = 1 - eased;
        ctx.beginPath();
        oldPath.context(ctx)(graticule);
        ctx.strokeStyle = gratStroke;
        ctx.lineWidth = 0.5;
        ctx.stroke();
        ctx.restore();
      }
      if (eased > 0) {
        ctx.save();
        ctx.globalAlpha = eased;
        ctx.beginPath();
        newPath.context(ctx)(graticule);
        ctx.strokeStyle = gratStroke;
        ctx.lineWidth = 0.5;
        ctx.stroke();
        ctx.restore();
      }

      // Points: interpolate positions and alpha
      projectedPoints = oldPoints.map((old, i) => {
        const target = newPoints[i];
        const alpha = old.alpha + (target.alpha - old.alpha) * eased;
        return {
          x: old.x + (target.x - old.x) * eased,
          y: old.y + (target.y - old.y) * eased,
          visible: alpha > 0 && (old.visible || target.visible),
          alpha,
          type: target.type,
          color: target.color
        };
      });

      // Draw points
      const filteredIndices = CONFIG.showWaterPoints
        ? projectedPoints.map((_: any, i: number) => i)
        : projectedPoints.map((p: any, i: number) => p.type !== 0 ? i : -1).filter((i: number) => i >= 0);

      filteredIndices.forEach((i: number) => {
        const p = projectedPoints[i];
        if (!p.visible) return;
        ctx.fillStyle = p.color || (p.type === 0 ? CONFIG.water : CONFIG.land);
        ctx.globalAlpha = CONFIG.pointOpacity * p.alpha;
        ctx.beginPath();
        ctx.arc(p.x, p.y, pointRadius, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.globalAlpha = 1;

      if (t < 1) {
        animationFrameId = requestAnimationFrame(animate);
      } else {
        projectedPoints = newPoints;
        graticuleOpacity = 1;
        animationFrameId = null;
        render(); // Final clean render
      }
    }

    animate();
  }


  function setupEventListeners() {
    // Mouse rotation controls for globe projections
    canvas.addEventListener('mousedown', (e: MouseEvent) => {
      const projConfig = getProjectionById(currentProjectionId);
      if (!projConfig?.isGlobe) return;
      
      isDragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      canvas.style.cursor = 'grabbing';
    });

    canvas.addEventListener('mousemove', (e: MouseEvent) => {
      const projConfig = getProjectionById(currentProjectionId);
      if (!projConfig?.isGlobe) return;
      
      // Update cursor based on hover state
      if (!isDragging) {
        canvas.style.cursor = 'grab';
      }
      
      if (!isDragging) return;
      
      const deltaX = e.clientX - lastMouseX;
      const deltaY = e.clientY - lastMouseY;
      
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      
      // Update rotation (sensitivity scaled by 0.5 for subtle movement)
      rotation[0] += deltaX * 0.5;
      rotation[1] -= deltaY * 0.5;
      
      // Clamp latitude rotation to prevent flipping
      rotation[1] = Math.max(-90, Math.min(90, rotation[1]));
      
      // Update projection with new rotation
      setupProjection(currentProjectionId);
      render();
    });

    canvas.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        const projConfig = getProjectionById(currentProjectionId);
        canvas.style.cursor = projConfig?.isGlobe ? 'grab' : 'default';
      }
    });

    canvas.addEventListener('mouseleave', () => {
      if (isDragging) {
        isDragging = false;
        canvas.style.cursor = 'default';
      }
    });

    // Touch rotation controls for mobile
    canvas.addEventListener('touchstart', (e: TouchEvent) => {
      const projConfig = getProjectionById(currentProjectionId);
      if (!projConfig?.isGlobe) return;
      
      // Prevent default to avoid scrolling while rotating
      if (e.touches.length === 1) {
        e.preventDefault();
        isDragging = true;
        lastMouseX = e.touches[0].clientX;
        lastMouseY = e.touches[0].clientY;
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e: TouchEvent) => {
      const projConfig = getProjectionById(currentProjectionId);
      if (!projConfig?.isGlobe || !isDragging) return;
      
      if (e.touches.length === 1) {
        e.preventDefault();
        
        const deltaX = e.touches[0].clientX - lastMouseX;
        const deltaY = e.touches[0].clientY - lastMouseY;
        
        lastMouseX = e.touches[0].clientX;
        lastMouseY = e.touches[0].clientY;
        
        // Update rotation (sensitivity scaled by 0.5 for subtle movement)
        rotation[0] += deltaX * 0.5;
        rotation[1] -= deltaY * 0.5;
        
        // Clamp latitude rotation to prevent flipping
        rotation[1] = Math.max(-90, Math.min(90, rotation[1]));
        
        // Update projection with new rotation
        setupProjection(currentProjectionId);
        render();
      }
    }, { passive: false });

    canvas.addEventListener('touchend', () => {
      if (isDragging) {
        isDragging = false;
      }
    });

    canvas.addEventListener('touchcancel', () => {
      if (isDragging) {
        isDragging = false;
      }
    });

    // Window resize
    let resizeTimer: number;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = window.setTimeout(() => {
        const container = document.querySelector('.canvas-container');
        if (!container) return;

        const rect = container.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        
        // Update point radius based on new canvas size
        pointRadius = getPointRadius(width);
        
        // Update canvas size with device pixel ratio
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        ctx.scale(dpr, dpr);

        setupProjection(currentProjectionId);
        render();
        syncControlsHeight();
      }, 150);
    });

    // Theme change observer
    const observer = new MutationObserver(() => {
      CONFIG = getThemeColors();
      render();
    });
    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class']
    });
  }

  function syncControlsHeight() {
    const container = document.querySelector('.canvas-container') as HTMLElement;
    const controls = document.getElementById('projection-controls') as HTMLElement;
    if (!container || !controls) return;
    
    // Get the actual rendered height of the canvas container
    const containerHeight = container.offsetHeight;
    controls.style.height = `${containerHeight}px`;
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>
