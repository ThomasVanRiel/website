---
// ProjectionVisualizer.astro - 2D map projection visualizer with animated transitions
---

<div class="projection-visualizer">
  <div class="canvas-container">
    <canvas id="globe-canvas"></canvas>
    <div class="drag-indicator" id="drag-indicator">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- Vertical arrows -->
        <path d="M12 4 L12 9" stroke="currentColor" stroke-width="1.0" stroke-linecap="round"/>
        <path d="M10 5.5 L12 4 L14 5.5" stroke="currentColor" stroke-width="1.0" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <path d="M12 20 L12 15" stroke="currentColor" stroke-width="1.0" stroke-linecap="round"/>
        <path d="M10 18.5 L12 20 L14 18.5" stroke="currentColor" stroke-width="1.0" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        
        <!-- Horizontal curved arrows -->
        <path d="M4 10 Q6 12.5 9 12" stroke="currentColor" stroke-width="1.0" stroke-linecap="round" fill="none"/>
        <path d="M4 12 L4 10 L6 9.5" stroke="currentColor" stroke-width="1.0" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <path d="M20 10 Q18 12.5 15 12" stroke="currentColor" stroke-width="1.0" stroke-linecap="round" fill="none"/>
        <path d="M20 12 L20 10 L18 9.5" stroke="currentColor" stroke-width="1.0" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        
        <!-- Center dot -->
        <circle cx="12" cy="12" r="1" fill="currentColor" opacity="0.5"/>
      </svg>
      <span>Drag to rotate</span>
    </div>
  </div>
  <div class="projection-controls" id="projection-controls">
    <!-- Projection list generated dynamically by category -->
  </div>
</div>

<style>
  .projection-visualizer {
    width: 100%;
    display: flex;
    gap: 20px;
    align-items: flex-start;
    justify-content: flex-start;
    /* background-color: rgba(0, 0, 0, 0.02); */
  }
  
  .canvas-container {
    min-width: 0;
    aspect-ratio: 1;
    max-height: 80vh;
    max-width: 80vh;
    width: min(80vh, calc(100% - 220px));
    position: relative;
    border-radius: 8px;
    overflow: hidden;
  }

  @media (max-width: 768px) {
    .projection-visualizer {
      gap: 12px;
    }
    
    .canvas-container {
      width: min(80vh, calc(100% - 162px));
    }
  }

  @media (max-width: 480px) {
    .projection-visualizer {
      gap: 8px;
    }
    
    .canvas-container {
      width: min(80vh, calc(100% - 128px));
    }
  }

  #globe-canvas {
    width: 100%;
    height: 100%;
    display: block;
    position: relative;
    z-index: 1;
    border-radius: 1rem;
  }

  #globe-canvas.projection-mode {
    cursor: default;
  }

  .drag-indicator {
    position: absolute;
    bottom: 12px;
    right: 12px;
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 10px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 6px;
    color: white;
    font-size: 11px;
    font-weight: 500;
    pointer-events: none;
    user-select: none;
    opacity: 0;
    transition: opacity 0.3s ease;
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
  }

  :global(.dark) .drag-indicator {
    background: rgba(255, 255, 255, 0.15);
  }

  .drag-indicator.visible {
    opacity: 0.7;
  }

  .drag-indicator:hover {
    opacity: 0.9;
  }

  .drag-indicator svg {
    flex-shrink: 0;
  }

  .drag-indicator span {
    white-space: nowrap;
  }

  @media (max-width: 768px) {
    .drag-indicator {
      bottom: 8px;
      right: 8px;
      padding: 4px 8px;
      font-size: 10px;
    }

    .drag-indicator svg {
      width: 20px;
      height: 20px;
    }
  }

  @media (max-width: 480px) {
    .drag-indicator span {
      display: none;
    }

    .drag-indicator {
      padding: 4px;
    }
  }

  .projection-controls {
    flex-shrink: 0;
    width: 150px;
    margin-left: auto;
    display: flex;
    flex-direction: column;
    gap: 4px;
    overflow-y: auto;
    overflow-x: visible;
    padding: 8px 12px;
    border-radius: 8px;
    /* background-color: rgba(0, 0, 0, 0.02); */
    
    /* Fade effect for overflowing content */
    mask-image: linear-gradient(to bottom, 
      transparent 0%, 
      black 3%, 
      black 90%, 
      transparent 100%);
    -webkit-mask-image: linear-gradient(to bottom, 
      transparent 0%, 
      black 3%, 
      black 90%, 
      transparent 100%);
    
    /* Visible scrollbar styling */
    scrollbar-width: thin;
    scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
  }



  .projection-controls::-webkit-scrollbar {
    width: 6px;
  }

  .projection-controls::-webkit-scrollbar-track {
    background: transparent;
  }

  .projection-controls::-webkit-scrollbar-thumb {
    background-color: rgba(156, 163, 175, 0.5);
    border-radius: 3px;
  }

  .projection-controls::-webkit-scrollbar-thumb:hover {
    background-color: rgba(156, 163, 175, 0.7);
  }

  @media (max-width: 768px) {
    .projection-controls {
      width: 140px;
      padding: 6px 8px;
    }
  }

  @media (max-width: 480px) {
    .projection-controls {
      width: 110px;
      padding: 4px 6px;
    }
  }

  /* Dynamically generated elements need global styles in Astro */
  .projection-controls :global(.category-group) {
    display: flex;
    flex-direction: column;
  }

  .projection-controls :global(.category-group:last-child) {
    padding-bottom: 20px;
  }

  .projection-controls :global(.category-label) {
    font-weight: 700;
    font-size: 13px;
    text-align: left;
    padding: 4px 0;
    color: var(--tw-prose-body);
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 6px;
  }

  .projection-controls :global(.category-label:hover) {
    opacity: 0.8;
  }

  .projection-controls :global(.category-arrow) {
    font-size: 8px;
    transition: transform 0.2s ease;
    display: inline-block;
    opacity: 0.4;
    font-weight: 400;
  }

  .projection-controls :global(.category-arrow.collapsed) {
    transform: rotate(-90deg);
  }

  .projection-controls :global(.category-items) {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    margin-left: 12px;
    transition: max-height 0.3s ease, opacity 0.2s ease;
    max-height: 1000px;
    opacity: 1;
    overflow: hidden;
  }

  .projection-controls :global(.category-items.collapsed) {
    max-height: 0;
    opacity: 0;
  }

  .projection-controls :global(.proj-item) {
    padding: 2px 0;
    cursor: pointer;
    font-size: 12px;
    transition: opacity 0.2s ease;
    opacity: 0.5;
    background: none;
    border: none;
    text-align: left;
    white-space: nowrap;
    font-family: inherit;
    font-weight: 400;
    color: var(--tw-prose-body);
  }

  .projection-controls :global(.proj-item:hover) {
    opacity: 1;
  }

  .projection-controls :global(.proj-item-active) {
    opacity: 1;
    font-weight: 500;
  }

  @media (max-width: 768px) {
    .projection-controls :global(.category-label) {
      font-size: 11px;
    }

    .projection-controls :global(.proj-item) {
      font-size: 10px;
    }
  }

</style>

<script>
  import * as d3 from 'd3';
  import { projections, getProjectionById, type DataPoint, type ProjectionConfig } from './projections';

  // Theme detection
  const isDarkTheme = () => document.documentElement.classList.contains('dark');
  
  const getThemeColors = () => {
    const dark = isDarkTheme();
    return {
      // Data point colors
      water: '#3b82f6',      // Blue for water points (same in both themes)
      land: dark ? '#fff' : '#000',  // White in dark mode, black in light mode
      pointOpacity: 0.9,  // Lower opacity in dark mode
      
      // City lights simulation
      cityLightsFraction: 0.03,  // 0.3% of land points become city lights
      cityLightsColors: [
        '#ffeecc',  // Soft warm white
        '#ffe6b3',  // Pale yellow-white
        '#ffd699',  // Light peach
        '#ffcc80',  // Warm cream
        '#ffdd99',  // Soft yellow
        '#ffc266',  // Light orange
        '#ffaa55',  // Warm orange
        '#ffbb66',  // Peach-orange
      ],
      
      // Display options
      showWaterPoints: false,
    };
  };

  // City lights: randomly determine if a point should be a city light
  const isCityLight = (lon: number, lat: number, type: number): boolean => {
    if (type === 0) return false; // Only land points can be city lights
    
    // Exclude equatorial regions (low urbanization in rainforests)
    if (Math.abs(lat) < 20) return false;
    
    // Exclude polar regions (minimal population)
    if (Math.abs(lat) > 65) return false;
    
    // Apply population density weighting based on latitude
    let densityMultiplier = 1.0;
    const absLat = Math.abs(lat);
    
    if (lat >= 30 && lat <= 60) {
      // Northern temperate zone (Europe, US, China, Japan) - highest density
      densityMultiplier = 5.0;
    } else if (lat >= 20 && lat < 30) {
      // Subtropical northern (Mexico, Middle East, North Africa)
      densityMultiplier = 2.5;
    } else if (lat > 60 && lat <= 65) {
      // Sub-polar northern (Scandinavia, Alaska, Russia)
      densityMultiplier = 0.8;
    } else if (lat <= -30 && lat >= -45) {
      // Southern temperate (Australia, South Africa, Argentina)
      densityMultiplier = 1.5;
    } else if (lat < -20 && lat > -30) {
      // Subtropical southern (Southern Brazil, Southern Africa)
      densityMultiplier = 1.2;
    }
    
    // Use coordinates as seed for consistent random selection
    const seed = Math.abs(Math.sin(lon * 12.9898 + lat * 78.233) * 43758.5453);
    return (seed % 1) < (CONFIG.cityLightsFraction * densityMultiplier);
  };

  // Get a random city light color
  const getCityLightColor = (lon: number, lat: number): string => {
    const seed = Math.abs(Math.sin(lon * 45.678 + lat * 23.456) * 87654.321);
    const index = Math.floor((seed % 1) * CONFIG.cityLightsColors.length);
    return CONFIG.cityLightsColors[index];
  };

  // Calculate point radius based on canvas size
  const getPointRadius = (canvasWidth: number): number => {
    // Scale radius: ~2.5px at 600px width, ~4px at 1000px width
    return Math.max(1, Math.min(4, canvasWidth / 200));
  };

  // Convert color from JSON to RGB string, darkening in dark mode
  const colorToRgb = (color: [number, number, number]): string => {
    const darkModeFactor = cachedIsDark ? 0.4 : 1.0; // Darken by 70% in dark mode
    const r = Math.round(color[0] * 255 * darkModeFactor);
    const g = Math.round(color[1] * 255 * darkModeFactor);
    const b = Math.round(color[2] * 255 * darkModeFactor);
    return `rgb(${r}, ${g}, ${b})`;
  };

  // ===== CONFIGURATION =====
  let CONFIG = getThemeColors();
  let pointRadius: number = 2.5; // Will be updated based on canvas size
  let cachedIsDark: boolean = isDarkTheme(); // Cache to avoid repeated calls during render
  // ========================

  // State
  let currentProjectionId: string = projections[0].id;
  let gridData: DataPoint[] = [];
  let canvas: HTMLCanvasElement;
  let ctx: CanvasRenderingContext2D;
  let width: number;
  let height: number;
  let projection: d3.GeoProjection;
  let path: d3.GeoPath;
  let rotation: [number, number, number] = [0, -30, 0]; // Greenwich, tilted up 50° latitude
  let animationFrameId: number | null = null;
  let graticuleOpacity: number = 0;
  let graticule: d3.GeoGeometryObjects;
  
  // Mouse interaction state
  let isDragging: boolean = false;
  let lastMouseX: number = 0;
  let lastMouseY: number = 0;
  
  // Cache projected coordinates for performance
  interface ProjectedPoint {
    x: number;
    y: number;
    visible: boolean;
    alpha: number;
    type: number;
    color?: string;
    isCityLight?: boolean;
  }
  let projectedPoints: ProjectedPoint[] = [];

  // Generate projection list organized by category
  function generateButtons() {
    const controlsContainer = document.getElementById('projection-controls');
    if (!controlsContainer) return;

    // Group projections by category (excluding disabled ones)
    const categories = new Map<string, ProjectionConfig[]>();
    projections.filter(proj => !proj.disable).forEach(proj => {
      if (!categories.has(proj.category)) {
        categories.set(proj.category, []);
      }
      categories.get(proj.category)!.push(proj);
    });

    let isFirst = true;

    // Create category groups
    categories.forEach((projs, category) => {
      const categoryGroup = document.createElement('div');
      categoryGroup.className = 'category-group';

      const categoryLabel = document.createElement('div');
      categoryLabel.className = 'category-label';
      
      const arrow = document.createElement('span');
      arrow.className = 'category-arrow';
      arrow.textContent = '▼';
      
      const labelText = document.createElement('span');
      labelText.textContent = category;
      
      categoryLabel.appendChild(labelText);
      categoryLabel.appendChild(arrow);
      categoryGroup.appendChild(categoryLabel);

      const itemsContainer = document.createElement('div');
      itemsContainer.className = 'category-items';
      
      // Toggle category visibility on label click
      categoryLabel.addEventListener('click', () => {
        const isCollapsed = itemsContainer.classList.toggle('collapsed');
        arrow.classList.toggle('collapsed', isCollapsed);
      });

      projs.forEach(proj => {
        const item = document.createElement('button');
        item.id = `btn-${proj.id}`;
        item.className = isFirst ? 'proj-item proj-item-active' : 'proj-item';
        item.textContent = proj.label;
        item.addEventListener('click', () => switchToProjection(proj.id));
        itemsContainer.appendChild(item);
        isFirst = false;
      });

      categoryGroup.appendChild(itemsContainer);
      controlsContainer.appendChild(categoryGroup);
    });
  }

  // Initialize
  async function init() {
    const container = document.querySelector('.canvas-container');
    if (!container) return;

    canvas = document.getElementById('globe-canvas') as HTMLCanvasElement;
    if (!canvas) return;
    
    ctx = canvas.getContext('2d', { alpha: true })!;

    const rect = container.getBoundingClientRect();
    width = rect.width;
    height = rect.height;
    
    // Calculate point radius based on canvas size
    pointRadius = getPointRadius(width);
    
    // Set canvas size with device pixel ratio for sharp rendering
    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    ctx.scale(dpr, dpr);

    // Generate projection list
    generateButtons();

    // Load data
    await loadGridData();

    // Setup initial projection
    setupProjection(currentProjectionId);

    // Render initial view
    graticuleOpacity = 1;
    render();

    // Sync controls height with canvas
    syncControlsHeight();

    // Set initial drag indicator visibility
    const dragIndicator = document.getElementById('drag-indicator');
    const initialProjConfig = getProjectionById(currentProjectionId);
    if (dragIndicator && initialProjConfig) {
      dragIndicator.classList.toggle('visible', initialProjConfig.isGlobe);
      // Set initial cursor
      canvas.style.cursor = initialProjConfig.isGlobe ? 'grab' : 'default';
    }

    // Setup event listeners
    setupEventListeners();
  }

  async function loadGridData() {
    try {
      const response = await fetch('/data/land_water_uniform_24000samples_ne1_color_land_only.json');
      const data = await response.json();

      gridData = Object.entries(data).map(([key, value]: [string, any]) => {
        const [lon, lat] = key.split(',').map(Number);
        const type = value.type as number;
        
        // Calculate city lights once during data load
        const cityLight = isCityLight(lon, lat, type);
        
        return { 
          lon, 
          lat, 
          type,
          color: value.color as [number, number, number] | undefined,
          isCityLight: cityLight,
          cityLightColor: cityLight ? getCityLightColor(lon, lat) : undefined
        };
      });
    } catch (error) {
      console.error('Failed to load grid data:', error);
      // Fallback: create sample data
      gridData = [];
      for (let lon = -180; lon < 180; lon += 5) {
        for (let lat = -90; lat < 90; lat += 5) {
          const type = Math.random() > 0.5 ? 1 : 0;
          const cityLight = isCityLight(lon, lat, type);
          gridData.push({ 
            lon, 
            lat, 
            type,
            isCityLight: cityLight,
            cityLightColor: cityLight ? getCityLightColor(lon, lat) : undefined
          });
        }
      }
    }
  }

  function setupProjection(projectionId: string) {
    const projConfig = getProjectionById(projectionId);
    if (!projConfig) return;

    projection = projConfig.setup(
      width,
      height,
      rotation,
      gridData,
      CONFIG.showWaterPoints
    );

    path = d3.geoPath().projection(projection);
    graticule = d3.geoGraticule()();
    projectPoints();
  }

  // Returns 0–1 alpha based on angular distance from clip edge (for globe projections)
  function getClipAlpha(lon: number, lat: number, proj: d3.GeoProjection): number {
    const clipAngle = (proj as any).clipAngle?.();
    if (clipAngle == null) return 1;

    const rot = proj.rotate();
    const cLon = -rot[0];
    const cLat = -rot[1];
    const toRad = Math.PI / 180;
    const cosD =
      Math.sin(cLat * toRad) * Math.sin(lat * toRad) +
      Math.cos(cLat * toRad) * Math.cos(lat * toRad) * Math.cos((lon - cLon) * toRad);
    const distance = Math.acos(Math.min(1, Math.max(-1, cosD))) / toRad;

    const fadeMargin = 10;
    if (distance <= clipAngle - fadeMargin) return 1;
    if (distance >= clipAngle) return 0;
    return (clipAngle - distance) / fadeMargin;
  }

  function projectPoints() {
    const isGlobe = getProjectionById(currentProjectionId)?.isGlobe ?? false;
    projectedPoints = gridData.map(d => {
      const coords = projection([d.lon, d.lat]);
      const alpha = isGlobe ? getClipAlpha(d.lon, d.lat, projection) : 1;
      
      // Use pre-calculated city light color in dark mode only, otherwise use regular colors
      let color: string | undefined;
      if (cachedIsDark && d.isCityLight && d.cityLightColor) {
        color = d.cityLightColor;
      } else if (d.color) {
        color = colorToRgb(d.color);
      }
      
      return {
        x: coords?.[0] ?? -9999,
        y: coords?.[1] ?? -9999,
        visible: alpha > 0 && coords != null && isFinite(coords[0]) && isFinite(coords[1]),
        alpha,
        type: d.type,
        color,
        isCityLight: cachedIsDark ? d.isCityLight : false
      };
    });
  }

  function render() {
    if (!ctx) return;
    
    // Clear canvas (transparent)
    ctx.clearRect(0, 0, width, height);
    
    const projConfig = getProjectionById(currentProjectionId);

    // Draw graticule/background
    if (graticuleOpacity > 0) {
      if (projConfig) {
        ctx.save();
        ctx.globalAlpha = graticuleOpacity;
        ctx.beginPath();
        path.context(ctx)({type: 'Sphere'});
        ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
        ctx.fill();
        ctx.restore();
      }
      
      ctx.save();
      ctx.globalAlpha = graticuleOpacity;
      ctx.beginPath();
      path.context(ctx)(graticule);
      ctx.strokeStyle = cachedIsDark ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.15)';
      ctx.lineWidth = 0.5;
      ctx.stroke();
      ctx.restore();
    }
    
    // Draw points
    const filteredIndices = CONFIG.showWaterPoints 
      ? projectedPoints.map((_, i) => i)
      : projectedPoints.map((p, i) => p.type !== 0 ? i : -1).filter(i => i >= 0);
    
    // First pass: draw regular points (non-city lights)
    filteredIndices.forEach(i => {
      const p = projectedPoints[i];
      if (!p.visible || p.isCityLight) return;
      
      // Use color if available, otherwise fall back to default colors
      ctx.fillStyle = p.color || (p.type === 0 ? CONFIG.water : CONFIG.land);
      ctx.globalAlpha = CONFIG.pointOpacity * p.alpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, pointRadius, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // Second pass: draw city lights on top
    filteredIndices.forEach(i => {
      const p = projectedPoints[i];
      if (!p.visible || !p.isCityLight) return;
      
      ctx.fillStyle = p.color || CONFIG.land;
      ctx.globalAlpha = 1.0 * p.alpha; // City lights at full opacity
      ctx.beginPath();
      ctx.arc(p.x, p.y, pointRadius, 0, Math.PI * 2);
      ctx.fill();
    });

    ctx.globalAlpha = 1;
  }

  function switchToProjection(newProjectionId: string) {
    if (newProjectionId === currentProjectionId) return;
    
    // Scroll to canvas with 10vh offset
    const canvasContainer = document.querySelector('.canvas-container');
    if (canvasContainer) {
      const offsetVh = window.innerHeight * 0.15; // 15vh
      const elementPosition = canvasContainer.getBoundingClientRect().top + window.pageYOffset;
      const offsetPosition = elementPosition - offsetVh;
      
      window.scrollTo({
        top: offsetPosition,
        behavior: 'smooth'
      });
    }
    
    // Check if switching from non-globe to globe
    const oldProjConfig = getProjectionById(currentProjectionId);
    const newProjConfig = getProjectionById(newProjectionId);
    const switchingToGlobe = oldProjConfig && newProjConfig && !oldProjConfig.isGlobe && newProjConfig.isGlobe;
    
    // Reset rotation when switching to a globe from a projection
    if (switchingToGlobe) {
      rotation = [0, -30, 0];
    }
    
    currentProjectionId = newProjectionId;
    
    // Update active states
    document.querySelectorAll('.proj-item').forEach(item => {
      item.classList.remove('proj-item-active');
    });
    document.getElementById(`btn-${newProjectionId}`)?.classList.add('proj-item-active');
    
    const canvasEl = document.getElementById('globe-canvas');
    const dragIndicator = document.getElementById('drag-indicator');
    const projConfig = getProjectionById(newProjectionId);
    if (canvasEl && projConfig) {
      canvasEl.classList.toggle('projection-mode', !projConfig.isGlobe);
      // Update cursor based on projection type
      canvasEl.style.cursor = projConfig.isGlobe ? 'grab' : 'default';
      
      // Show/hide drag indicator
      if (dragIndicator) {
        dragIndicator.classList.toggle('visible', projConfig.isGlobe);
      }
    }

    // Animate transition
    animateTransition();
  }

  function animateTransition() {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }

    // Save old state
    const oldPath = path;
    const oldPoints = [...projectedPoints];

    // Setup new projection
    setupProjection(currentProjectionId);
    const newProjection = projection;
    const newPath = path;
    const projConfig = getProjectionById(currentProjectionId);

    // Calculate new projected points
    const isGlobe = projConfig?.isGlobe ?? false;
    const newPoints = gridData.map(d => {
      const coords = newProjection([d.lon, d.lat]);
      const alpha = isGlobe ? getClipAlpha(d.lon, d.lat, newProjection) : 1;
      
      // Use pre-calculated city light color in dark mode only, otherwise use regular colors
      let color: string | undefined;
      if (cachedIsDark && d.isCityLight && d.cityLightColor) {
        color = d.cityLightColor;
      } else if (d.color) {
        color = colorToRgb(d.color);
      }
      
      return {
        x: coords?.[0] ?? -9999,
        y: coords?.[1] ?? -9999,
        visible: alpha > 0 && coords != null && isFinite(coords[0]) && isFinite(coords[1]),
        alpha,
        type: d.type,
        color,
        isCityLight: cachedIsDark ? d.isCityLight : false
      };
    });

    const duration = 1000;
    const startTime = performance.now();

    function animate() {
      const elapsed = performance.now() - startTime;
      const t = Math.min(elapsed / duration, 1);
      const eased = d3.easeQuadInOut(t);

      ctx.clearRect(0, 0, width, height);

      // Sphere fill: crossfade between old and new outlines
      if (projConfig) {
        if (eased < 1) {
          ctx.save();
          ctx.globalAlpha = 1 - eased;
          ctx.beginPath();
          oldPath.context(ctx)({type: 'Sphere'});
          ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
          ctx.fill();
          ctx.restore();
        }
        if (eased > 0) {
          ctx.save();
          ctx.globalAlpha = eased;
          ctx.beginPath();
          newPath.context(ctx)({type: 'Sphere'});
          ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
          ctx.fill();
          ctx.restore();
        }
      }

      // Graticule: crossfade
      const gratStroke = cachedIsDark ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.15)';
      if (eased < 1) {
        ctx.save();
        ctx.globalAlpha = 1 - eased;
        ctx.beginPath();
        oldPath.context(ctx)(graticule);
        ctx.strokeStyle = gratStroke;
        ctx.lineWidth = 0.5;
        ctx.stroke();
        ctx.restore();
      }
      if (eased > 0) {
        ctx.save();
        ctx.globalAlpha = eased;
        ctx.beginPath();
        newPath.context(ctx)(graticule);
        ctx.strokeStyle = gratStroke;
        ctx.lineWidth = 0.5;
        ctx.stroke();
        ctx.restore();
      }

      // Points: interpolate positions and alpha
      projectedPoints = oldPoints.map((old, i) => {
        const target = newPoints[i];
        const alpha = old.alpha + (target.alpha - old.alpha) * eased;
        return {
          x: old.x + (target.x - old.x) * eased,
          y: old.y + (target.y - old.y) * eased,
          visible: alpha > 0 && (old.visible || target.visible),
          alpha,
          type: target.type,
          color: target.color,
          isCityLight: target.isCityLight
        };
      });

      // Draw points
      const filteredIndices = CONFIG.showWaterPoints
        ? projectedPoints.map((_: any, i: number) => i)
        : projectedPoints.map((p: any, i: number) => p.type !== 0 ? i : -1).filter((i: number) => i >= 0);

      // First pass: draw regular points (non-city lights)
      filteredIndices.forEach((i: number) => {
        const p = projectedPoints[i];
        if (!p.visible || p.isCityLight) return;
        ctx.fillStyle = p.color || (p.type === 0 ? CONFIG.water : CONFIG.land);
        ctx.globalAlpha = CONFIG.pointOpacity * p.alpha;
        ctx.beginPath();
        ctx.arc(p.x, p.y, pointRadius, 0, Math.PI * 2);
        ctx.fill();
      });
      
      // Second pass: draw city lights on top
      filteredIndices.forEach((i: number) => {
        const p = projectedPoints[i];
        if (!p.visible || !p.isCityLight) return;
        ctx.fillStyle = p.color || CONFIG.land;
        ctx.globalAlpha = 1.0 * p.alpha; // City lights at full opacity
        ctx.beginPath();
        ctx.arc(p.x, p.y, pointRadius, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.globalAlpha = 1;

      if (t < 1) {
        animationFrameId = requestAnimationFrame(animate);
      } else {
        projectedPoints = newPoints;
        graticuleOpacity = 1;
        animationFrameId = null;
        render(); // Final clean render
      }
    }

    animate();
  }


  function setupEventListeners() {
    // Mouse rotation controls for globe projections
    canvas.addEventListener('mousedown', (e: MouseEvent) => {
      const projConfig = getProjectionById(currentProjectionId);
      if (!projConfig?.isGlobe) return;
      
      isDragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      canvas.style.cursor = 'grabbing';
    });

    canvas.addEventListener('mousemove', (e: MouseEvent) => {
      const projConfig = getProjectionById(currentProjectionId);
      if (!projConfig?.isGlobe) return;
      
      // Update cursor based on hover state
      if (!isDragging) {
        canvas.style.cursor = 'grab';
      }
      
      if (!isDragging) return;
      
      const deltaX = e.clientX - lastMouseX;
      const deltaY = e.clientY - lastMouseY;
      
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      
      // Update rotation (sensitivity scaled by 0.5 for subtle movement)
      rotation[0] += deltaX * 0.5;
      rotation[1] -= deltaY * 0.5;
      
      // Clamp latitude rotation to prevent flipping
      rotation[1] = Math.max(-90, Math.min(90, rotation[1]));
      
      // Update projection with new rotation
      setupProjection(currentProjectionId);
      render();
    });

    canvas.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        const projConfig = getProjectionById(currentProjectionId);
        canvas.style.cursor = projConfig?.isGlobe ? 'grab' : 'default';
      }
    });

    canvas.addEventListener('mouseleave', () => {
      if (isDragging) {
        isDragging = false;
        canvas.style.cursor = 'default';
      }
    });

    // Touch rotation controls for mobile
    canvas.addEventListener('touchstart', (e: TouchEvent) => {
      const projConfig = getProjectionById(currentProjectionId);
      if (!projConfig?.isGlobe) return;
      
      // Prevent default to avoid scrolling while rotating
      if (e.touches.length === 1) {
        e.preventDefault();
        isDragging = true;
        lastMouseX = e.touches[0].clientX;
        lastMouseY = e.touches[0].clientY;
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e: TouchEvent) => {
      const projConfig = getProjectionById(currentProjectionId);
      if (!projConfig?.isGlobe || !isDragging) return;
      
      if (e.touches.length === 1) {
        e.preventDefault();
        
        const deltaX = e.touches[0].clientX - lastMouseX;
        const deltaY = e.touches[0].clientY - lastMouseY;
        
        lastMouseX = e.touches[0].clientX;
        lastMouseY = e.touches[0].clientY;
        
        // Update rotation (sensitivity scaled by 0.5 for subtle movement)
        rotation[0] += deltaX * 0.5;
        rotation[1] -= deltaY * 0.5;
        
        // Clamp latitude rotation to prevent flipping
        rotation[1] = Math.max(-90, Math.min(90, rotation[1]));
        
        // Update projection with new rotation
        setupProjection(currentProjectionId);
        render();
      }
    }, { passive: false });

    canvas.addEventListener('touchend', () => {
      if (isDragging) {
        isDragging = false;
      }
    });

    canvas.addEventListener('touchcancel', () => {
      if (isDragging) {
        isDragging = false;
      }
    });

    // Window resize
    let resizeTimer: number;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = window.setTimeout(() => {
        const container = document.querySelector('.canvas-container');
        if (!container) return;

        const rect = container.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        
        // Update point radius based on new canvas size
        pointRadius = getPointRadius(width);
        
        // Update canvas size with device pixel ratio
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        ctx.scale(dpr, dpr);

        setupProjection(currentProjectionId);
        render();
        syncControlsHeight();
      }, 150);
    });

    // Theme change observer
    const observer = new MutationObserver(() => {
      cachedIsDark = isDarkTheme();
      CONFIG = getThemeColors();
      projectPoints(); // Recalculate colors for new theme
      render();
    });
    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class']
    });
  }

  function syncControlsHeight() {
    const container = document.querySelector('.canvas-container') as HTMLElement;
    const controls = document.getElementById('projection-controls') as HTMLElement;
    if (!container || !controls) return;
    
    // Get the actual rendered height of the canvas container
    const containerHeight = container.offsetHeight;
    controls.style.height = `${containerHeight}px`;
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>
