---
// MachiningWindow.astro
---

<div id="machining-container" class="w-full h-[48rem] overflow-hidden border-2 border-dashed" style="background: transparent;">
</div>

<!-- Sliders will be dynamically inserted here -->
<div id="slider-container" class="flex gap-4 mt-4">
</div>

<script>
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { SliderGenerator } from './SliderGenerator.ts';
    
    const objects: THREE.Object3D[] = [];
    
    let bhmin = 0.2;
    let bhmax = 0.8;
    
    function initMachiningWindow() {
        const container = document.getElementById('machining-container');
        const sliderContainer = document.getElementById('slider-container');
        if (!container || !sliderContainer) return;
        
        // Initialize slider generator
        const sliderGen = new SliderGenerator();
        
        // Create sliders using the generator
        const bhminSlider = sliderGen.createSlider({
            name: 'bhmin',
            min: 0.01,
            max: 0.99,
            step: 0.01,
            defaultValue: 0.2,
            displayPrecision: 2,
            label: 'b/h min',
            containerClass: 'flex flex-col',
            onUpdate: (value) => {
                bhmin = value;
                Generate();
            }
        });
        
        const bhmaxSlider = sliderGen.createSlider({
            name: 'bhmax',
            min: 0.01,
            max: 0.99,
            step: 0.01,
            defaultValue: 0.8,
            displayPrecision: 2,
            label: 'b/h max',
            containerClass: 'flex flex-col',
            onUpdate: (value) => {
                bhmax = value;
                Generate();
            }
        });
        
        // Add sliders to container
        sliderContainer.appendChild(bhminSlider.container);
        sliderContainer.appendChild(bhmaxSlider.container);
        
        // Scene setup (keeping your existing Three.js code)
        const scene = new THREE.Scene();
        // Remove background to make it transparent
        scene.background = null;
        
        // Camera setup
        const aspect = container.clientWidth / container.clientHeight;
        const frustumSize = 2;
        const camera = new THREE.OrthographicCamera(
            -frustumSize * aspect / 2,
            frustumSize * aspect / 2,
            frustumSize / 2,
            -frustumSize / 2,
            0.1,
            1000
        );
        camera.position.set(2, 2, 3);
        camera.lookAt(0, 0, 0);
        
        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor(0x000000, 0); // Transparent background
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0.5, 0.5, 0.5);
        controls.enablePan = false;
        controls.enableRotate = true;
        controls.enableZoom = false;
        controls.update();
        
        container.appendChild(renderer.domElement);
        
        const axesColor = new THREE.Color(0x000000);
        
        // Create grid
        const gridHelper = new THREE.GridHelper(1, 10, 0xcccccc, 0xcccccc);
        gridHelper.translateX(0.5);
        gridHelper.translateZ(0.5);
        scene.add(gridHelper);
        
        // Create axes
        const axesHelper = new THREE.AxesHelper(1);
        axesHelper.setColors(axesColor, axesColor, axesColor);
        scene.add(axesHelper);
        
        // Materials
        const dashedLineMaterial = new THREE.LineDashedMaterial({ 
            color: 0x000, 
            linewidth: 1, 
            scale: 1, 
            dashSize: 0.03, 
            gapSize: 0.01 
        });
        
        // Add axis labels
        const createAxisLabel = (text: string, position: THREE.Vector3, size: number = 1) => {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            if (ctx) {
                ctx.font = `bold 128px 'Source Serif 4'`;
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            }
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.2*size, 0.2*size, 0.2*size);
            sprite.position.copy(position);
            return sprite;
        };
        
        // Axis labels
        scene.add(createAxisLabel('v', new THREE.Vector3(0, 1.1, 0)));
        scene.add(createAxisLabel('h', new THREE.Vector3(1.1, 0, 0)));
        scene.add(createAxisLabel('b', new THREE.Vector3(0, 0, 1.1)));
        
        const Generate = () => {
            // Remove old surface from scene
            for (let obj of objects) {
                scene.remove(obj);
            }
            objects.length = 0; // Clear the array
            
            // Draw bhmax line
            const bhmaxPoints = [];
            bhmaxPoints.push(new THREE.Vector3(0, 0, 0));
            if (bhmax > 0.5) {
                bhmaxPoints.push(new THREE.Vector3((1-bhmax)*2, 0, 1));
            } else if (bhmax < 0.5) {
                bhmaxPoints.push(new THREE.Vector3(1, 0, (bhmax)*2));
            } else {
                bhmaxPoints.push(new THREE.Vector3(1, 0, 1));
            }
            
            const bhmaxGeometry = new THREE.BufferGeometry().setFromPoints(bhmaxPoints);
            const bhmaxLine = new THREE.Line(bhmaxGeometry, dashedLineMaterial);
            bhmaxLine.computeLineDistances();
            objects.push(bhmaxLine);
            scene.add(bhmaxLine);
            
            // Draw bhmin line
            const bhminPoints = [];
            bhminPoints.push(new THREE.Vector3(0, 0, 0));
            if (bhmin > 0.5) {
                bhminPoints.push(new THREE.Vector3((1-bhmin)*2, 0, 1));
            } else if (bhmin < 0.5) {
                bhminPoints.push(new THREE.Vector3(1, 0, (bhmin)*2));
            } else {
                bhminPoints.push(new THREE.Vector3(1, 0, 1));
            }
            
            const bhminGeometry = new THREE.BufferGeometry().setFromPoints(bhminPoints);
            const bhminLine = new THREE.Line(bhminGeometry, dashedLineMaterial);
            bhminLine.computeLineDistances();
            objects.push(bhminLine);
            scene.add(bhminLine);
        };
        
        // Initial generation
        Generate();
        
        // Animation loop
        let animationId: number;
        const animate = () => {
            animationId = requestAnimationFrame(animate);
            renderer.render(scene, camera);
        };
        
        // Handle window resize
        const handleResize = () => {
            if (!container) return;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        };
        
        window.addEventListener('resize', handleResize);
        
        // Start animation
        animate();
        
        // Cleanup function
        return () => {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            window.removeEventListener('resize', handleResize);
            if (container && renderer.domElement) {
                container.removeChild(renderer.domElement);
            }
            renderer.dispose();
        };
    }
    
    // Initialize when DOM is loaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initMachiningWindow);
    } else {
        initMachiningWindow();
    }
</script>

<style>
    #machining-container {
        position: relative;
    }
    
    #three-canvas-container canvas {
        display: block;
    }
    
    /* Enhanced slider styling */
    input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        background: #e5e7eb;
        border-radius: 9999px;
        height: 8px;
        outline: none;
        transition: background 0.3s ease;
    }
    
    input[type="range"]:hover {
        background: #d1d5db;
    }
    
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #ffffff;
        border: 2px solid #374151;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
    }
    
    input[type="range"]::-webkit-slider-thumb:hover {
        background: #f3f4f6;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }
    
    input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #ffffff;
        border: 2px solid #374151;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
    }
    
    input[type="range"]::-moz-range-thumb:hover {
        background: #f3f4f6;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }
</style>