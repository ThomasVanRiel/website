---
// AI Notice: Mainly vibecoded
// TODO: Refactor to separate JS logic into its own file for better maintainability
// TODO: Relax the flowchart layout to reduce edge crossings and improve readability
---


<div class="my-8">
  <div class="mb-4">
    <label for="recipe-input" class="block text-sm font-medium mb-2">
      Enter a recipe (one step per line):
    </label>
    <textarea
      id="recipe-input"
      rows="8"
      class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-800 dark:text-gray-100 font-mono text-sm"
      placeholder="Add PO-TA-TOES
Boil 'em
Mash 'em
Stick 'em in a stew
Out"
    ></textarea>
    <div class="flex gap-2 mt-2">
      <button
        id="generate-flowchart"
        class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md transition-colors"
      >
        Generate Flowchart
      </button>
      <button
        id="save-svg"
        class="px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-md transition-colors"
      >
        Save as SVG
      </button>
      <button
        id="save-png"
        class="px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-md transition-colors"
      >
        Save as PNG
      </button>
      <label class="ml-2 flex items-center gap-2 text-sm">
        <input type="checkbox" id="toggle-pots" checked />
        <span>Show cookware</span>
      </label>
      
    </div>
  </div>
  <div id="recipe-flowchart"></div>
</div>

<script>
  import * as d3 from 'd3';
  import rough from 'roughjs';
  import * as ClipperLib from 'clipper-lib';


  // Type definitions
  type NodeGroup = 'ingredient' | 'process' | 'output';
  
  interface Node {
    id: string;
    label: string;
    group: NodeGroup;
    x?: number;
    y?: number;
    fx?: number | null;
    fy?: number | null;
  }
  
  interface Link {
    source: string | Node;
    target: string | Node;
  }
  
  interface GraphData {
    nodes: Node[];
    links: Link[];
  }

  interface Ingredient {
    name: string;
    amount: string;
  }

  // Default recipe data
  const defaultRecipeData: GraphData = {
    nodes: [
      // Ingredients
      { id: "eggs", label: "2 Eggs", group: "ingredient" },
      { id: "butter", label: "Butter", group: "ingredient" },
      { id: "salt", label: "Salt", group: "ingredient" },
      { id: "pepper", label: "Pepper", group: "ingredient" },
      
      // Processes
      { id: "crack", label: "Crack eggs", group: "process" },
      { id: "whisk", label: "Whisk", group: "process" },
      { id: "heat", label: "Heat pan", group: "process" },
      { id: "melt", label: "Melt butter", group: "process" },
      { id: "pour", label: "Pour eggs", group: "process" },
      { id: "scramble", label: "Scramble (2 min)", group: "process" },
      { id: "season", label: "Season", group: "process" },
      
      // Output
      { id: "serve", label: "Serve", group: "output" }
    ],
    links: [
      { source: "eggs", target: "crack" },
      { source: "crack", target: "whisk" },
      { source: "whisk", target: "pour" },
      { source: "butter", target: "heat" },
      { source: "heat", target: "melt" },
      { source: "melt", target: "pour" },
      { source: "pour", target: "scramble" },
      { source: "scramble", target: "season" },
      { source: "salt", target: "season" },
      { source: "pepper", target: "season" },
      { source: "season", target: "serve" }
    ]
  };

  let currentData: GraphData = defaultRecipeData;
  let svg: any, simulation: any, link: any, node: any, linkGroup: any, nodeGroup: any;
  let voronoiGroup: any;
  let potColorMapGlobal: Map<string,string> = new Map();
  let rc: any; // Rough.js renderer

  const width = 700;
  const height = 800;
  const nodeRadius = 40;
  const rectWidthMultiplier = 2.4;
  const rectHeightMultiplier = 1.2;
  const rectPadding = 5; // Gap between rectangle edge and links
  const arrowSize = 5;
  const linkDistance = 140;
  const nodeRepulsion = -800;
  // Grid attractor settings (keeps process nodes aligned to a regular grid)
  const gridX = 100; // horizontal grid spacing (px)
  const gridY = 150; // vertical grid spacing (px)
  const gridAttractorStrength = 0.75; // how strongly nodes are pulled toward the grid (0-1)
  
  // Font sizes
  const titleFontSize = 24;
  const nodeFontSize = 16;
  const nodeSubtextFontSize = 14;
  const ingredientListFontSize = 16;
  
  // Quadrant dimensions
  const topRowHeight = 40;
  const leftColumnWidth = width / 4; // 1 part
  const rightColumnWidth = (width * 3) / 4; // 3 parts
  const quadrantHeight = height - topRowHeight;
  const quadrantPadding = 4; // Padding for quadrant rectangles
  const voronoiPadding = 10; // Inset Voronoi cells from flowchart edges
  const voronoiRounding = 50; // Corner rounding radius for Voronoi cells (px)
  const voronoiInsetPad = 10; // Pixels to inset merged Voronoi cells after union (positive -> shrink)
  const voronoiMergePadStart = 0; // Starting padding (px) when attempting unions
  const voronoiMergeAttempts = 5; // Number of times to retry union (doubling padding each attempt)
  
  // Rough.js sketch style parameters
  const sketchStrokeWidth = 1;
  const sketchRoughness = 1.5;
  const sketchBowing = 1.5;
  const sketchFillStyle = 'zigzag'; // Fill style for output nodes: 'hachure', 'solid', 'zigzag', 'cross-hatch', 'dots', 'dashed', 'zigzag-line'
  // Voronoi rough fill: prefer hachure (parallel hatch lines). Adjust gap/weight for thicker lines.
  const voronoiFillStyle = 'zigzag'; // 'hachure' draws parallel lines (good for thick-line fill)
  const voronoiFillGap = 16; // Distance between hatch lines (px). Lower = denser lines.
  const voronoiFillWeight = 4; // Line weight for hatch strokes (px)
  const voronoiFillOpacity = 0.2; // Opacity for Voronoi fill strokes
  
  // Toggle options
  const showFlowchartBorder = false; // Set to true to show border around flowchart quadrant
  let showPots = true; // Toggle to render pot Voronoi regions and legend

  // Keep last ingredients so toggle can re-render legend without reparsing
  let lastIngredients: Ingredient[] = [];

  // Color scale for different node types
  const colorScale = d3.scaleOrdinal()
    .domain(["ingredient", "process", "output"])
    .range(["#93c5fd", "#fcd34d", "#86efac"]);

  function initSVG() {
    d3.select("#recipe-flowchart").selectAll("*").remove();
    
    // Create SVG
    svg = d3.select("#recipe-flowchart")
      .append("svg")
      .attr("width", "100%")
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr("style", "max-width: 100%; height: auto;");

    // Initialize Rough.js
    rc = rough.svg(svg.node());

    // Add title blocks
    // Top-left: Ingredients
    svg.append("text")
      .attr("x", leftColumnWidth / 2)
      .attr("y", 28)
      .attr("text-anchor", "middle")
      .attr("font-size", `${titleFontSize}px`)
      .attr("font-family", "xkcd Script, cursive")
      .attr("font-weight", "bold")
      .attr("fill", "var(--text-color)")
      .text("Ingredients");
    
    // Top-right: Instructions
    svg.append("text")
      .attr("x", leftColumnWidth + rightColumnWidth / 2)
      .attr("y", 28)
      .attr("text-anchor", "middle")
      .attr("font-size", `${titleFontSize}px`)
      .attr("font-family", "xkcd Script, cursive")
      .attr("font-weight", "bold")
      .attr("fill", "var(--text-color)")
      .text("Instructions");

    // Get computed border color and node stroke color
    const borderColor = 'currentColor';
    const nodeStrokeColor = 'currentColor';

    // Draw sketch-style rectangles using Rough.js with dynamic CSS colors
    // Top-left quadrant (Ingredients title)
    const topLeftRect = rc.rectangle(
      quadrantPadding,
      quadrantPadding,
      leftColumnWidth - 2 * quadrantPadding,
      topRowHeight - 2 * quadrantPadding,
      {
        stroke: borderColor,
        strokeWidth: sketchStrokeWidth,
        roughness: sketchRoughness,
        bowing: sketchBowing
      }
    );
    svg.node().appendChild(topLeftRect);

    // Top-right quadrant (Instructions title)
    const topRightRect = rc.rectangle(
      leftColumnWidth + quadrantPadding,
      quadrantPadding,
      rightColumnWidth - 2 * quadrantPadding,
      topRowHeight - 2 * quadrantPadding,
      {
        stroke: borderColor,
        strokeWidth: sketchStrokeWidth,
        roughness: sketchRoughness,
        bowing: sketchBowing
      }
    );
    svg.node().appendChild(topRightRect);

    // Bottom-left quadrant (Ingredients list) - will be updated by displayIngredients
    const bottomLeftRect = rc.rectangle(
      quadrantPadding,
      topRowHeight + quadrantPadding,
      leftColumnWidth - 2 * quadrantPadding,
      quadrantHeight - 2 * quadrantPadding,
      {
        stroke: borderColor,
        strokeWidth: sketchStrokeWidth,
        roughness: sketchRoughness,
        bowing: sketchBowing
      }
    );
    bottomLeftRect.classList.add('ingredients-border');
    svg.node().appendChild(bottomLeftRect);

    // Bottom-right quadrant (Flowchart)
    if (showFlowchartBorder) {
      const bottomRightRect = rc.rectangle(
        leftColumnWidth + quadrantPadding,
        topRowHeight + quadrantPadding,
        rightColumnWidth - 2 * quadrantPadding,
        quadrantHeight - 2 * quadrantPadding,
        {
          stroke: borderColor,
          strokeWidth: sketchStrokeWidth,
          roughness: sketchRoughness,
          bowing: sketchBowing
        }
      );
      svg.node().appendChild(bottomRightRect);
    }

    // Create arrow marker for directed edges with explicit color
    const arrowColor = 'currentColor';
    svg.append("defs").selectAll("marker")
      .data(["arrowhead"])
      .join("marker")
      .attr("id", (d: string) => d)
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 9)
      .attr("refY", 5)
      .attr("markerWidth", arrowSize)
      .attr("markerHeight", arrowSize)
      .attr("orient", "auto-start-reverse")
      .append("path")
      .attr("d", "M 0 0 L 10 5 L 0 10 z")
      .attr("fill", arrowColor)
      .attr("stroke", arrowColor);

    // Create groups for links and nodes (bottom-right quadrant for flowchart)
    // Voronoi background group (rendered first so it's behind links/nodes)
    voronoiGroup = svg.append("g").attr("transform", `translate(${leftColumnWidth}, ${topRowHeight})`).attr('class', 'voronoi-bg');

    linkGroup = svg.append("g").attr("transform", `translate(${leftColumnWidth}, ${topRowHeight})`);
    nodeGroup = svg.append("g").attr("transform", `translate(${leftColumnWidth}, ${topRowHeight})`);
  }

  function renderFlowchart(data: GraphData) {
        // Get node stroke color from CSS variable for current theme
        const nodeStrokeColor = 'currentColor';
    currentData = data;
    
    // Create force simulation (within bottom-right quadrant)
    if (simulation) {
      simulation.stop();
    }
    
    simulation = d3.forceSimulation(data.nodes)
      .force("link", d3.forceLink(data.links)
        .id((d: any) => d.id)
        .distance(linkDistance))
      .force("charge", d3.forceManyBody().strength(nodeRepulsion))
      .force("center", d3.forceCenter(rightColumnWidth / 2, quadrantHeight / 2))
      .force("collision", d3.forceCollide().radius((d: any) => d.group === "ingredient" ? 25 : nodeRadius * Math.max(rectWidthMultiplier, rectHeightMultiplier) / 2))
      .force("x", d3.forceX(rightColumnWidth / 2).strength(0.1))
      .force("y", d3.forceY((d: any) => d.group === "output" ? quadrantHeight - 80 : quadrantHeight / 2).strength((d: any) => d.group === "output" ? 0.5 : 0.1))
      // Grid attractor keeps process nodes visually aligned in columns/rows
      .force("grid", forceGrid(gridX, gridY, gridAttractorStrength))
      // Ingredient grid keeps ingredient nodes aligned in a compact left column
      .force("ingredientGrid", forceIngredientGrid(gridX, gridY, gridAttractorStrength, 0));

    // Create links
    linkGroup.selectAll("*").remove();
    const linkColor = 'currentColor';
    link = linkGroup
      .selectAll("line")
      .data(data.links)
      .join("line")
      .attr("stroke", linkColor)
      .attr("stroke-width", 2)
      .attr("color", linkColor)
      .attr("marker-end", "url(#arrowhead)");

    // Create nodes
    nodeGroup.selectAll("*").remove();
    node = nodeGroup
      .selectAll("g")
      .data(data.nodes)
      .join("g")
      .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

    // Create/update Voronoi cells for process nodes â€” include the final Serve node so it affects cell layout
    const processNodes = data.nodes.filter((d: Node) =>
      d.group === 'process' || (d.group === 'output' && String(d.label).trim().toLowerCase() === 'serve')
    );

    // Helper: extract pot name from a process label (looks for last " in ")
    const extractPot = (label: string | undefined) => {
      if (!label) return null;
      const idx = label.lastIndexOf(' in ');
      if (idx === -1) return null;
      return label.slice(idx + 4).trim();
    };

    // Escape string for use in RegExp
    const escapeRegExp = (s: string) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    // Build a palette mapped to pot names so colors are stable
    const palette = ['#f97316','#f59e0b','#ef4444','#10b981','#3b82f6','#8b5cf6','#ec4899','#06b6d4','#f43f5e','#a3e635'];
    // Collect pot names, ensure uniqueness, then sort alphabetically so color
    // assignment is deterministic and the legend is ordered.
    const potNames = Array.from(
      new Set(processNodes.map((n: any) => extractPot(n.label)).filter(Boolean))
    ).map(String).sort((a, b) => a.localeCompare(b));
    const potColorMap = new Map<string,string>();
    potNames.forEach((p: any, i: number) => potColorMap.set(p, palette[i % palette.length]));
    // Expose the pot -> color mapping for the legend
    potColorMapGlobal = potColorMap;
    // Helper: build a rounded SVG path from a polygon (quadratic curve at each corner)
    // Default rounding is `voronoiRounding`; rr inside will clamp to edge lengths when needed
    const roundedPathFromPolygon = (poly: [number, number][], r = voronoiRounding) => {
      if (!poly || poly.length === 0) return '';
      const n = poly.length;
      // helper math
      const dist = (a: number[], b: number[]) => Math.hypot(a[0]-b[0], a[1]-b[1]);
      const norm = (a: number[]) => { const L = Math.hypot(a[0], a[1])||1; return [a[0]/L, a[1]/L]; };

      const pA: [number, number][] = new Array(n);
      const pB: [number, number][] = new Array(n);

      for (let i = 0; i < n; i++) {
        const prev = poly[(i - 1 + n) % n];
        const curr = poly[i];
        const next = poly[(i + 1) % n];

        const toPrev = [prev[0] - curr[0], prev[1] - curr[1]] as number[];
        const toNext = [next[0] - curr[0], next[1] - curr[1]] as number[];
        const dPrev = dist(curr, prev);
        const dNext = dist(curr, next);
        const rr = Math.min(r, dPrev / 2, dNext / 2);

        const nPrev = norm(toPrev);
        const nNext = norm(toNext);

        pA[i] = [curr[0] + nPrev[0] * rr, curr[1] + nPrev[1] * rr];
        pB[i] = [curr[0] + nNext[0] * rr, curr[1] + nNext[1] * rr];
      }

      // Build path: move to pB[last], then for each vertex line to pA[i] then quadratic to pB[i] with control at curr
      let d = '';
      const start = pB[(n - 1) % n];
      d += `M ${start[0]} ${start[1]}`;
      for (let i = 0; i < n; i++) {
        const curr = poly[i];
        const a = pA[i];
        const b = pB[i];
        d += ` L ${a[0]} ${a[1]} Q ${curr[0]} ${curr[1]} ${b[0]} ${b[1]}`;
      }
      d += ' Z';
      return d;
    };

    // Grid attractor force: nudges process nodes toward the nearest grid cell.
    // Implemented as a custom d3 force so it participates naturally with other forces.
    function forceGrid(gridX = 140, gridY = 100, strength = 0.2) {
      let nodes: any[] | undefined;
      function force(alpha: number) {
        if (!nodes) return;
        for (const d of nodes) {
          // Only apply to process nodes (keep ingredients and outputs free)
          if (!d || d.group !== 'process') continue;
          if (typeof d.x !== 'number' || typeof d.y !== 'number') continue;

          const gx = Math.round(d.x / gridX) * gridX;
          const gy = Math.round(d.y / gridY) * gridY;

          // Apply a small velocity change toward the grid point. Scale with alpha.
          d.vx = (d.vx || 0) + (gx - d.x) * strength * alpha;
          d.vy = (d.vy || 0) + (gy - d.y) * strength * alpha;
        }
      }
      force.initialize = function(_nodes: any[]) { nodes = _nodes; };
      return force;
    }

    // Ingredient grid force: gently aligns ingredient nodes to a narrow
    // column grid near the left side of the flowchart area so they are
    // visually ordered and avoid overlapping links.
    function forceIngredientGrid(gridX = 80, gridY = 80, strength = 0.6, offsetX = 40) {
      let nodes: any[] | undefined;
      function force(alpha: number) {
        if (!nodes) return;
        for (const d of nodes) {
          if (!d || d.group !== 'ingredient') continue;
          if (typeof d.x !== 'number' || typeof d.y !== 'number') continue;

          // Compute nearest grid cell within the ingredient column region
          const gx = Math.round((d.x - offsetX) / gridX) * gridX + offsetX;
          const gy = Math.round(d.y / gridY) * gridY;

          // Apply a mild velocity toward the grid cell scaled by alpha
          d.vx = (d.vx || 0) + (gx - d.x) * strength * alpha;
          d.vy = (d.vy || 0) + (gy - d.y) * strength * alpha;
        }
      }
      force.initialize = function(_nodes: any[]) { nodes = _nodes; };
      return force;
    }

    // Add rounded rectangles to nodes (only for non-ingredient nodes)
    node.filter((d: Node) => d.group !== "ingredient")
      .each(function(this: SVGGElement, d: Node) {
        const g = d3.select(this);
        const rectWidth = nodeRadius * rectWidthMultiplier;
        const rectHeight = nodeRadius * rectHeightMultiplier;
        const x = -rectWidth / 2;
        const y = -rectHeight / 2;

        // Get stroke and fill color based on node type and current theme
        const strokeColor = nodeStrokeColor;
        const fillColor = d.group === "output" ? 'rgba(0, 91, 249, 0.2)' : 'none';

        // Create rough rectangle
        const roughRect = rc.rectangle(x, y, rectWidth, rectHeight, {
          stroke: strokeColor,
          strokeWidth: sketchStrokeWidth,
          fill: fillColor,
          fillStyle: d.group === "output" ? sketchFillStyle : 'solid',
          roughness: sketchRoughness,
          bowing: sketchBowing
        });

        this.appendChild(roughRect);
        roughRect.style.cursor = 'grab';
      });

    // Add invisible overlay for process nodes to make them draggable
    node.filter((d: Node) => d.group === "process")
      .append("rect")
      .attr("x", -nodeRadius * rectWidthMultiplier / 2)
      .attr("y", -nodeRadius * rectHeightMultiplier / 2)
      .attr("width", nodeRadius * rectWidthMultiplier)
      .attr("height", nodeRadius * rectHeightMultiplier)
      .attr("fill", "transparent")
      .attr("stroke", "none")
      .style("cursor", "grab");

      // Add invisible overlay for output nodes to keep them draggable (for filled/sketch style nodes)
      node.filter((d: Node) => d.group === "output")
        .append("rect")
        .attr("x", -nodeRadius * rectWidthMultiplier / 2)
        .attr("y", -nodeRadius * rectHeightMultiplier / 2)
        .attr("width", nodeRadius * rectWidthMultiplier)
        .attr("height", nodeRadius * rectHeightMultiplier)
        .attr("fill", "transparent")
        .attr("stroke", "none")
        .style("cursor", "grab");

    // Add invisible larger circle for ingredient nodes to make them draggable
    node.filter((d: Node) => d.group === "ingredient")
      .append("circle")
      .attr("r", 20)
      .attr("fill", "transparent")
      .attr("stroke", "none")
      .style("cursor", "grab");

    // Add labels to nodes
    node.append("text")
      .attr("text-anchor", "middle")
      .attr("dy", "0.3em")
      .attr("font-size", `${nodeFontSize}px`)
      .attr("font-family", "xkcd Script, cursive")
      .attr("fill", "var(--text-color)")
      .style("pointer-events", "none")
      .style("user-select", "none")
      .each(function(this: SVGTextElement, d: Node) {
        const text = d3.select(this);

        // Compute a display label that strips the trailing " in <pot>" while preserving parenthetical clarification
        const raw = d.label || '';
        const pot = extractPot(raw);
        const displayLabel = pot ? raw.replace(new RegExp(`\\s+in\\s+${escapeRegExp(pot)}\\s*$`), '').trim() : raw;

        // Check for clarification in brackets on the display label
        const bracketMatch = displayLabel.match(/^(.+?)\s*\(([^)]+)\)$/);

        if (bracketMatch) {
          const mainText = bracketMatch[1].trim();
          const clarification = bracketMatch[2].trim();

          text.append("tspan")
            .attr("x", 0)
            .attr("dy", "-0.3em")
            .text(mainText);
          text.append("tspan")
            .attr("x", 0)
            .attr("dy", "1.2em")
            .attr("font-size", `${nodeSubtextFontSize}px`)
            .attr("fill", "var(--text-muted)")
            .text(`(${clarification})`);
        } else {
          const words = displayLabel.split(" ");
          if (words.length === 1) {
            text.text(displayLabel);
          } else {
            text.append("tspan")
              .attr("x", 0)
              .attr("dy", "-0.3em")
              .text(words.slice(0, -1).join(" "));
            text.append("tspan")
              .attr("x", 0)
              .attr("dy", "1.2em")
              .text(words[words.length - 1]);
          }
        }
      });

    // Update positions on simulation tick
    simulation.on("tick", () => {
      // Constrain node positions within quadrant bounds
      data.nodes.forEach((d: Node) => {
        const margin = d.group === "ingredient" ? 30 : nodeRadius * Math.max(rectWidthMultiplier, rectHeightMultiplier) / 2 * 1.2;
        d.x = Math.max(margin, Math.min(rightColumnWidth - margin, d.x ?? 0));
        d.y = Math.max(margin, Math.min(quadrantHeight - margin, d.y ?? 0));
      });

      // Update Voronoi polygons based on current process node positions
      if (showPots) {
      try {
        // Ensure the points array is typed as an array of number tuples so
        // TypeScript accepts it for d3.Delaunay.from
        const points: Array<[number, number]> = processNodes.map((n: any) => [n.x ?? 0, n.y ?? 0] as [number, number]);
        if (points.length > 0) {
          const delaunay = d3.Delaunay.from(points);
          const voronoi = delaunay.voronoi([
            voronoiPadding,
            voronoiPadding,
            rightColumnWidth - voronoiPadding,
            quadrantHeight - voronoiPadding
          ]);

          // Remove previous rough Voronoi shapes
          voronoiGroup.selectAll('.voronoi-rough').remove();

          // Group Voronoi cells by pot so neighbouring cells of the same pot can be drawn as one shape
          const cellsByPot = new Map<string, Array<[number, number][]>>();
          processNodes.forEach((n: any, i: number) => {
            const cell = voronoi.cellPolygon(i);
            if (!cell || cell.length === 0) return;
            const pot = extractPot(n.label);
            if (!pot) return;
            if (!cellsByPot.has(pot)) cellsByPot.set(pot, []);
            cellsByPot.get(pot)!.push(cell as [number, number][]);
          });

          // For each pot, concatenate rounded paths and draw once with Rough.js (fill-only, no stroke)
          cellsByPot.forEach((polys, pot) => {
            const hex = potColorMap.get(pot) || palette[0];
            const fillCol = d3.color(hex);
            if (fillCol) fillCol.opacity = voronoiFillOpacity;

            const rounding = voronoiRounding;

            // Attempt to union neighbouring polygons for this pot so we can
            // stroke/round the outer boundary once. Fall back to simple
            // concatenation if union fails.
            let combinedPath = '';
            try {
              // Expand each polygon slightly so neighbouring cells overlap
              // and `polygon-clipping.union` has a better chance to merge them.
              // Use Clipper to produce a robust outward offset of each polygon
              // before unioning. Clipper works with integer coordinates, so scale
              // geometry by `clipperScale` then scale back.
              const clipperScale = 100; // scale factor for integer Clipper coordinates

              const offsetPolygonWithClipper = (ring: [number, number][], pad: number) => {
                if (!ring || ring.length === 0) return ring;
                try {
                  const co = new (ClipperLib as any).ClipperOffset();
                  const path = ring.map(([x, y]) => ({ X: Math.round(x * clipperScale), Y: Math.round(y * clipperScale) }));
                  // Close path if necessary
                  if (path.length > 0) {
                    const first = path[0];
                    const last = path[path.length - 1];
                    if (first.X !== last.X || first.Y !== last.Y) path.push({ X: first.X, Y: first.Y });
                  }
                  co.AddPath(path, (ClipperLib as any).JoinType.jtRound, (ClipperLib as any).EndType.etClosedPolygon);
                  const solution = new (ClipperLib as any).Paths();
                  co.Execute(solution, pad * clipperScale);
                  if (solution && solution.length > 0) {
                    // Return the first resulting path as array of [x,y]
                    const out = solution[0].map((pt: any) => [pt.X / clipperScale, pt.Y / clipperScale] as [number, number]);
                    return out;
                  }
                } catch (e) {
                  // fall through to return original ring
                }
                return ring;
              };

              const closeRing = (ring: [number, number][]) => {
                if (!ring || ring.length === 0) return ring;
                const first = ring[0];
                const last = ring[ring.length - 1];
                if (first[0] !== last[0] || first[1] !== last[1]) {
                  return [...ring, [first[0], first[1]]];
                }
                return ring;
              };

              // Try union with increasing padding if initial attempt yields no merged polygons.
              const tryUnionWithPadding = (polysArr: [number, number][][], startPad: number, maxAttempts = voronoiMergeAttempts) => {
                let pad = startPad;
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                  try {
                    const expanded = polysArr.map(p => closeRing(offsetPolygonWithClipper(p, pad)));
                    const args = expanded.map(p => [p]);
                    // First try Clipper union (robust integer boolean ops)
                    let result: any = null;
                    try {
                      const c = new (ClipperLib as any).Clipper();
                      const subj = (expanded as any).map((ring: any) =>
                        (ring as any).map((p: any) => ({ X: Math.round(p[0] * clipperScale), Y: Math.round(p[1] * clipperScale) }))
                      );
                      c.AddPaths(subj, (ClipperLib as any).PolyType.ptSubject, true);
                      const sol = new (ClipperLib as any).Paths();
                      const succeeded = c.Execute((ClipperLib as any).ClipType.ctUnion, sol, (ClipperLib as any).PolyFillType.pftNonZero, (ClipperLib as any).PolyFillType.pftNonZero);
                      if (succeeded && sol && sol.length > 0) {
                        // Convert Paths -> polygon-clipping like structure: array of polygons, each polygon is array of rings
                        result = sol.map((path: any) => [path.map((pt: any) => [pt.X / clipperScale, pt.Y / clipperScale])]);
                      }
                    } catch (e) {
                      // ignore and try polygon-clipping as fallback
                    }

                    // No polygon-clipping fallback: rely on Clipper's union result.
                    // If Clipper couldn't produce a union, leave `result` as null
                    // and fall back to the convex-hull/concatenation logic below.

                    if (result && result.length > 0) return result;
                  } catch (e) {
                    // ignore and increase padding
                  }
                  pad *= 2;
                }
                return null;
              };

              const unionResult = tryUnionWithPadding(polys, voronoiMergePadStart, voronoiMergeAttempts);
              if (!unionResult) {
                // union failed; skip inset step
              }
              if (unionResult && unionResult.length > 0) {
                // unionResult is an array of polygons; each polygon is an array of rings
                // Optionally inset (shrink) the merged polygons by `voronoiInsetPad`.
                let finalPolys: any = unionResult;
                if (typeof voronoiInsetPad === 'number' && voronoiInsetPad > 0) {
                  try {
                    const insetAttempt = unionResult.map((poly: any) => {
                      return poly.map((ring: [number, number][]) => {
                        const inset = offsetPolygonWithClipper(ring, -voronoiInsetPad);
                        // If inset produced a valid polygon (>=3 points), use it; otherwise keep original ring
                        if (inset && inset.length >= 3) return inset;
                        return ring;
                      });
                    }).filter((p: any) => p && p.length > 0);

                    if (insetAttempt && insetAttempt.length > 0) {
                      finalPolys = insetAttempt;
                    }
                  } catch (e) {
                    // If inset fails for any reason, fall back to the original union result
                    finalPolys = unionResult;
                  }
                }

                combinedPath = finalPolys.map((poly: any) => {
                  // For each ring in the polygon (outer ring + holes) create a rounded path
                  return poly.map((ring: [number, number][]) => roundedPathFromPolygon(ring, rounding)).join(' ');
                }).join(' ');
              } else {
                // Fallback: if union failed, build a convex hull of all vertices
                const allPoints: [number, number][] = [];
                polys.forEach(p => p.forEach(pt => allPoints.push([pt[0], pt[1]] as [number, number])));

                const convexHull = (pts: [number, number][]) => {
                  if (!pts || pts.length === 0) return [] as [number, number][];
                  // Unique points
                  const map = new Map<string, [number, number]>();
                  for (const p of pts) map.set(p[0] + ',' + p[1], p);
                  const uniq = Array.from(map.values());
                  if (uniq.length <= 2) return uniq;
                  uniq.sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);
                  const cross = (o: [number, number], a: [number, number], b: [number, number]) => (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0]);
                  const lower: [number, number][] = [];
                  for (const p of uniq) {
                    while (lower.length >= 2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop();
                    lower.push(p);
                  }
                  const upper: [number, number][] = [];
                  for (let i = uniq.length - 1; i >= 0; i--) {
                    const p = uniq[i];
                    while (upper.length >= 2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop();
                    upper.push(p);
                  }
                  upper.pop(); lower.pop();
                  const hull = lower.concat(upper);
                  return hull.length ? hull : uniq;
                };

                const hull = convexHull(allPoints);
                if (hull && hull.length > 0) {
                  // Try insetting the convex hull as well
                  try {
                    const insetHull = offsetPolygonWithClipper(hull, -voronoiInsetPad);
                    if (insetHull && insetHull.length >= 3) {
                      combinedPath = roundedPathFromPolygon(insetHull, rounding);
                    } else {
                      combinedPath = roundedPathFromPolygon(hull, rounding);
                    }
                  } catch (e) {
                    combinedPath = roundedPathFromPolygon(hull, rounding);
                  }
                } else {
                  combinedPath = polys.map(p => roundedPathFromPolygon(p, rounding)).join(' ');
                }
              }
            } catch (err) {
              // If polygon union fails for any reason, fall back to concatenating
              // the individual rounded polygons so we still render something.
              combinedPath = polys.map(p => roundedPathFromPolygon(p, rounding)).join(' ');
            }

            // Draw Voronoi region with Rough.js for sketchy look. If Rough fails,
            // fall back to plain SVG path so rendering still occurs.
            try {
              // Build an RGBA color string that includes the voronoiFillOpacity
              const d3col = d3.color(hex);
              const fillWithAlpha = d3col
                ? `rgba(${Math.round((d3col as any).r)},${Math.round((d3col as any).g)},${Math.round((d3col as any).b)},${voronoiFillOpacity})`
                : hex;

              // Render with Rough.js using hachure fill and no outline stroke so
              // regions are represented by thick parallel hatch lines.
              const roughPath = (rc as any).path(combinedPath, {
                // Remove outline by disabling stroke
                stroke: 'none',
                strokeWidth: 0,
                // Fill using the voronoiFillStyle (hachure) and color (includes alpha)
                fill: fillWithAlpha,
                fillStyle: voronoiFillStyle,
                // Control density/weight of hatch lines for a thicker appearance
                hachureGap: voronoiFillGap,
                fillWeight: voronoiFillWeight,
                roughness: sketchRoughness,
                bowing: sketchBowing
              }) as SVGElement;
              roughPath.classList.add('voronoi-rough');
              roughPath.setAttribute('fill-rule', 'evenodd');
              roughPath.style.pointerEvents = 'none';
              // Append the Rough.js-generated node into the voronoi group
              voronoiGroup.node().appendChild(roughPath);
            } catch (e) {
              // Fallback to plain SVG path without outline (fill-only)
              const d3col = d3.color(hex);
              const fillWithAlpha = d3col
                ? `rgba(${Math.round((d3col as any).r)},${Math.round((d3col as any).g)},${Math.round((d3col as any).b)},${voronoiFillOpacity})`
                : hex;

              voronoiGroup.append('path')
                .attr('class', 'voronoi-rough')
                .attr('d', combinedPath)
                .attr('fill', fillWithAlpha)
                .attr('fill-rule', 'evenodd')
                .attr('stroke', 'none')
                .attr('stroke-width', 0)
                .style('pointer-events', 'none');
            }
          });
        }
      } catch (e) {
        // Voronoi calculation can fail briefly while nodes are NaN during simulation start; ignore
      }
      } else {
        // If pots are disabled, ensure voronoi background is cleared
        try { voronoiGroup.selectAll('.voronoi-rough').remove(); } catch (e) { }
      }
      
      link.each(function(this: SVGLineElement, d: any) {
        const dx = d.target.x - d.source.x;
        const dy = d.target.y - d.source.y;
        const dr = Math.sqrt(dx * dx + dy * dy);
        
        // Function to calculate intersection with rectangle edge
        const getRectEdgePoint = (centerX: number, centerY: number, toX: number, toY: number, isIngredient: boolean) => {
          if (isIngredient) {
            // For ingredients, use simple offset
            const offset = 20;
            return {
              x: centerX + ((toX - centerX) * offset) / dr,
              y: centerY + ((toY - centerY) * offset) / dr
            };
          }
          
          // For rectangles
          const rectWidth = nodeRadius * rectWidthMultiplier;
          const rectHeight = nodeRadius * rectHeightMultiplier;
          const angle = Math.atan2(toY - centerY, toX - centerX);
          
          // Check which edge the line intersects
          const absAngle = Math.abs(angle);
          const cornerAngle = Math.atan2(rectHeight, rectWidth);
          
          let edgeX, edgeY;
          if (absAngle < cornerAngle) {
            // Right edge
            edgeX = centerX + (rectWidth / 2 + rectPadding);
            edgeY = centerY + (edgeX - centerX) * Math.tan(angle);
          } else if (absAngle > Math.PI - cornerAngle) {
            // Left edge
            edgeX = centerX - (rectWidth / 2 + rectPadding);
            edgeY = centerY + (edgeX - centerX) * Math.tan(angle);
          } else if (angle > 0) {
            // Bottom edge
            edgeY = centerY + (rectHeight / 2 + rectPadding);
            edgeX = centerX + (edgeY - centerY) / Math.tan(angle);
          } else {
            // Top edge
            edgeY = centerY - (rectHeight / 2 + rectPadding);
            edgeX = centerX + (edgeY - centerY) / Math.tan(angle);
          }
          
          return { x: edgeX, y: edgeY };
        };
        
        const sourcePoint = getRectEdgePoint(d.source.x, d.source.y, d.target.x, d.target.y, d.source.group === "ingredient");
        const targetPoint = getRectEdgePoint(d.target.x, d.target.y, d.source.x, d.source.y, d.target.group === "ingredient");
        
        d3.select(this)
          .attr("x1", sourcePoint.x)
          .attr("y1", sourcePoint.y)
          .attr("x2", targetPoint.x)
          .attr("y2", targetPoint.y);
      });

      node.attr("transform", (d: Node) => `translate(${d.x},${d.y})`);
    });
  }

  // Drag functions
  function dragstarted(event: any) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }

  function dragged(event: any) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }

  function dragended(event: any) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }

  // Parse recipe text input
  function parseRecipe(text: string): { graphData: GraphData; ingredients: Ingredient[] } {
    const lines = text.trim().split('\n').filter(line => line.trim());
    
    const nodes: Node[] = [];
    const links: Link[] = [];
    const ingredients: Ingredient[] = [];
    const nodeMap = new Map<string, Node>(); // Track nodes by their content
    const linkSet = new Set<string>(); // Prevent duplicate links
    let nodeId = 0;
    let lastProcessNode: Node | null = null;
    const subprocesses = new Map<string, any[]>(); // Track subprocess outputs
    
    const addLink = (source: string, target: string) => {
      const key = `${source}->${target}`;
      if (!linkSet.has(key)) {
        links.push({ source, target });
        linkSet.add(key);
      }
    };
    
    let i = 0;
    while (i < lines.length) {
      const line = lines[i].trim();
      
      // Handle subprocess definition
      if (line.startsWith('Subprocess ')) {
        const match = line.match(/Subprocess\s+(\w+)/);
        if (!match) {
          i++;
          continue;
        }
        const subprocessName = match[1];
        const subprocessLines = [];
        i++; // Skip opening brace line
        
        // Collect subprocess lines
        while (i < lines.length && !lines[i].trim().startsWith('}')) {
          const subLine = lines[i].trim();
          if (subLine) subprocessLines.push(subLine);
          i++;
        }
        
        // Process subprocess
        let subLastNode: Node | null = null;
        let subOutputs: any[] = [];
        let pendingSubIngredients: Node[] = [];
        
        subprocessLines.forEach((subLine: string, idx: number) => {
          if (subLine.startsWith('Add ')) {
            let ingredient = subLine.substring(4).trim();
            let amount = '';
            
            // Extract amount in curly braces if present (format: Add ingredient {amount})
            const amountMatch = ingredient.match(/^(.+?)\s*\{([^}]+)\}$/);
            if (amountMatch) {
              ingredient = amountMatch[1].trim();
              amount = amountMatch[2].trim();
            }
            
            // Add to ingredients list if not from a subprocess
            if (!ingredient.includes(' from ')) {
              ingredients.push({ name: ingredient, amount });
            }
            
            // Check if it's from another subprocess
            const fromMatch = ingredient.match(/^(.+?)\s+from\s+(\w+)$/);
            if (fromMatch) {
              const [, outputName, fromSubprocessName] = fromMatch;
              const fromSubOutputs = subprocesses.get(fromSubprocessName) || [];
              
              // Find the matching output from the other subprocess
              let fromSubOutput;
              if (outputName === '.') {
                fromSubOutput = fromSubOutputs[fromSubOutputs.length - 1];
              } else {
                fromSubOutput = fromSubOutputs.find((o: any) => o.name === outputName);
              }
              
              // Add this output node to pending ingredients
              if (fromSubOutput && fromSubOutput.node) {
                pendingSubIngredients.push(fromSubOutput.node);
              }
            } else {
              // Regular ingredient
              if (!nodeMap.has(ingredient)) {
                const id = `node${nodeId++}`;
                const node: Node = { id, label: ingredient, group: "ingredient" };
                nodes.push(node);
                nodeMap.set(ingredient, node);
              }
              const ingredientNode = nodeMap.get(ingredient);
              if (ingredientNode) {
                pendingSubIngredients.push(ingredientNode);
              }
            }
          } else if (subLine.startsWith('Out ')) {
            const outputName = subLine.substring(4).trim();
            if (subLastNode) {
              // Create an intermediary ingredient node for named outputs
              if (outputName !== '.') {
                const outputId = `node${nodeId++}`;
                const outputNode: Node = { id: outputId, label: outputName, group: "ingredient" };
                nodes.push(outputNode);
                nodeMap.set(`${subprocessName}_${outputName}`, outputNode);
                
                // Link the last subprocess step to the output node
                addLink(subLastNode.id, outputId);
                
                subOutputs.push({ node: outputNode, name: outputName });
              } else {
                // For '.', use the last process node directly
                subOutputs.push({ node: subLastNode, name: '.' });
              }
            }
          } else {
            // Process step
            const id = `node${nodeId++}`;
            const node: Node = { id, label: subLine, group: "process" };
            nodes.push(node);
            
            // Link pending ingredients to this step
            pendingSubIngredients.forEach((ingNode: Node) => {
              addLink(ingNode.id, id);
            });
            pendingSubIngredients = [];
            
            // Link to previous subprocess step
            if (subLastNode) {
              addLink(subLastNode.id, id);
            }
            
            subLastNode = node;
          }
        });
        
        // Store subprocess outputs
        subprocesses.set(subprocessName, subOutputs);
        
      } else if (line.startsWith('Add ')) {
        let ingredient = line.substring(4).trim();
        let amount = '';
        
        // Extract amount in curly braces if present (format: Add ingredient {amount})
        const amountMatch = ingredient.match(/^(.+?)\s*\{([^}]+)\}$/);
        if (amountMatch) {
          ingredient = amountMatch[1].trim();
          amount = amountMatch[2].trim();
        }
        
        // Add to ingredients list if not from a subprocess
        if (!ingredient.includes(' from ')) {
          ingredients.push({ name: ingredient, amount });
        }
        
        // Check if it's from a subprocess
        const fromMatch = ingredient.match(/^(.+?)\s+from\s+(\w+)$/);
        if (fromMatch) {
          const [, outputName, subprocessName] = fromMatch;
          const subOutputs = subprocesses.get(subprocessName) || [];
          
          // Find the matching output
          let subOutput;
          if (outputName === '.') {
            // '.' refers to the last output of the subprocess
            subOutput = subOutputs[subOutputs.length - 1];
          } else {
            subOutput = subOutputs.find((o: any) => o.name === outputName);
          }
          
          // Find the next process step and link to it
          for (let j = i + 1; j < lines.length; j++) {
            const nextLine = lines[j].trim();
            if (!nextLine.startsWith('Add ') && !nextLine.startsWith('Subprocess ') && !nextLine.startsWith('}')) {
              // This is the next process step, link subprocess output to it
              const nextId = `next_${j}`;
              // We'll link this after we create the node
              if (subOutput) {
                // Store for later linking
                if (!subOutput.pendingLinks) subOutput.pendingLinks = [];
                subOutput.pendingLinks.push(j);
              }
              break;
            }
          }
        } else {
          // Regular ingredient
          if (!nodeMap.has(ingredient)) {
            const id = `node${nodeId++}`;
            const node: Node = { id, label: ingredient, group: "ingredient" };
            nodes.push(node);
            nodeMap.set(ingredient, node);
          }
        }
        
      } else if (line && !line.startsWith('}')) {
        // Check if this is an Out statement at the end (final output)
        if (line.startsWith('Out')) {
          const id = `node${nodeId++}`;
          const node: Node = { id, label: 'Serve', group: "output" };
          nodes.push(node);
          
          // Link from last process step
          if (lastProcessNode) {
            addLink(lastProcessNode.id, id);
          }
          
          // Link subprocess outputs if this is their target
          for (const [subName, outputs] of subprocesses) {
            outputs.forEach((output: any) => {
              if (output.pendingLinks && output.pendingLinks.includes(i)) {
                addLink(output.node.id, id);
              }
            });
          }
          
          // Link any immediately preceding ingredients to this final node
          for (let j = i - 1; j >= 0; j--) {
            const prevLine = lines[j].trim();
            if (prevLine.startsWith('Add ') && !prevLine.includes(' from ')) {
              let ingredient = prevLine.substring(4).trim();
              // Remove amount if present
              const amountMatch = ingredient.match(/^(.+?)\s*\{([^}]+)\}$/);
              if (amountMatch) {
                ingredient = amountMatch[1].trim();
              }
              const ingredientNode = nodeMap.get(ingredient);
              if (ingredientNode) {
                addLink(ingredientNode.id, id);
              }
            } else if (!prevLine.startsWith('Add ')) {
              break;
            }
          }
          
          lastProcessNode = node;
        } else {
          // Process step
          const id = `node${nodeId++}`;
          // Check if there's an Out after this line
          const hasOutAfter = lines.slice(i + 1).some((l: string) => l.trim().startsWith('Out'));
          const node: Node = { id, label: line, group: hasOutAfter ? "process" : "output" };
          nodes.push(node);
          
          // Link to previous process step
          if (lastProcessNode) {
            addLink(lastProcessNode.id, id);
          }
          
          // Link any immediately preceding ingredients to this step (not from subprocess)
          for (let j = i - 1; j >= 0; j--) {
            const prevLine = lines[j].trim();
            if (prevLine.startsWith('Add ') && !prevLine.includes(' from ')) {
              let ingredient = prevLine.substring(4).trim();
              // Remove amount if present
              const amountMatch = ingredient.match(/^(.+?)\s*\{([^}]+)\}$/);
              if (amountMatch) {
                ingredient = amountMatch[1].trim();
              }
              const ingredientNode = nodeMap.get(ingredient);
              if (ingredientNode) {
                addLink(ingredientNode.id, id);
              }
            } else if (!prevLine.startsWith('Add ')) {
              break;
            }
          }
          
          // Link subprocess outputs if this is their target
          for (const [subName, outputs] of subprocesses) {
            outputs.forEach((output: any) => {
              if (output.pendingLinks && output.pendingLinks.includes(i)) {
                addLink(output.node.id, id);
              }
            });
          }
          
          lastProcessNode = node;
        }
      }
      
      i++;
    }
    
    return { graphData: { nodes, links }, ingredients };
  }

  // Initialize with stoofvlees recipe
  const stoofvleesRecipe = `Subprocess Grill {
    Add meat {1 kg}
    Grill (in butter) in Braising pan
    Out meat
    Add Beer {2 bottles}
    Cook in Braising pan
    Out sauce
}

Subprocess Bread {
    Add Bread {1 slice}
    Add Mustard {2 Tb.}
    Smear
    Out .
}

Add Onion {2}
Chop
SautÃ© (in butter) in Casserole
Add meat from Grill
Add sauce from Grill
Add Laurel
Add Thyme
Add Cloves {1}
Add Sirup {1 Tb.}
Add . from Bread
Simmer (on low heat) in Casserole
Add Vinegar
Out`;

  initSVG();
  const parsedRecipe = parseRecipe(stoofvleesRecipe);
  renderFlowchart(parsedRecipe.graphData);
  displayIngredients(parsedRecipe.ingredients);
  displayInstructions();

  // Function to display ingredients list
  function displayIngredients(ingredients: Ingredient[]) {
    // Remove previous ingredient text, borders and legend
    svg.selectAll(".ingredient-text").remove();
    svg.selectAll(".ingredients-border").remove();
    svg.selectAll(".pot-legend").remove();
    svg.selectAll('.pot-legend-box').remove();
    svg.selectAll('.pot-legend-swatch').remove();

    // remember last ingredients so the pots toggle can re-render the legend
    lastIngredients = ingredients;
    
    const borderColor = 'currentColor';
    
    if (ingredients.length === 0) {
      // Create minimal border when no ingredients
      const minBorder = rc.rectangle(
        quadrantPadding,
        topRowHeight + quadrantPadding,
        leftColumnWidth - 2 * quadrantPadding,
        60,
        { 
          stroke: borderColor,
          strokeWidth: sketchStrokeWidth,
          roughness: sketchRoughness,
          bowing: sketchBowing
        }
      );
      minBorder.classList.add('ingredients-border');
      svg.node().appendChild(minBorder);
      return;
    }
    
    // Sort ingredients alphabetically
    const sortedIngredients = [...ingredients].sort((a, b) => 
      a.name.localeCompare(b.name)
    );
    
    // Display in bottom-left quadrant
    const startY = topRowHeight + 40;
    const lineHeight = 24;
    const nameX = 20;
    const amountX = leftColumnWidth - 20; // Right-aligned position
    
    sortedIngredients.forEach((ing, index) => {
      const yPos = startY + index * lineHeight;
      
      // Ingredient name (left-aligned)
      svg.append("text")
        .attr("class", "ingredient-text")
        .attr("x", nameX)
        .attr("y", yPos)
        .attr("font-size", `${ingredientListFontSize}px`)
        .attr("font-family", "xkcd Script, cursive")
        .attr("fill", "var(--text-color)")
        .text(ing.name);
      
      // Amount (right-aligned)
      if (ing.amount) {
        svg.append("text")
          .attr("class", "ingredient-text")
          .attr("x", amountX)
          .attr("y", yPos)
          .attr("text-anchor", "end")
          .attr("font-size", `${ingredientListFontSize}px`)
          .attr("font-family", "xkcd Script, cursive")
          .attr("fill", "var(--text-muted)")
          .text(`(${ing.amount})`);
      }
    });
    
    // Update border height to fit the ingredient list using Rough.js
    const listHeight = sortedIngredients.length * lineHeight + 60;
    const finalHeight = Math.min(listHeight, quadrantHeight - 2 * quadrantPadding);
    
    const newBorder = rc.rectangle(
      quadrantPadding,
      topRowHeight + quadrantPadding,
      leftColumnWidth - 2 * quadrantPadding,
      finalHeight,
      { 
        stroke: borderColor,
        strokeWidth: sketchStrokeWidth,
        roughness: sketchRoughness,
        bowing: sketchBowing
      }
    );
    newBorder.classList.add('ingredients-border');
    svg.node().appendChild(newBorder);

    // Render legend for pots below the ingredient list inside a Rough.js box
    const legendEntries = Array.from(potColorMapGlobal.entries());
    if (showPots && legendEntries.length > 0) {
      const itemHeight = 18;
      const boxPadding = 10;
      const boxX = quadrantPadding;
      const boxWidth = leftColumnWidth - 2 * quadrantPadding;
      const legendStartY = topRowHeight + finalHeight + 12; // top of legend box

      // Calculate legend box height and clamp to remaining quadrant space
      const legendContentHeight = legendEntries.length * itemHeight + boxPadding * 2;
      const maxAvailable = quadrantHeight - finalHeight - 2 * quadrantPadding;
      const boxHeight = Math.min(legendContentHeight, Math.max(itemHeight + boxPadding * 2, maxAvailable));

      // Draw rough rectangle for legend
      const legendRect = rc.rectangle(
        boxX,
        legendStartY,
        boxWidth,
        boxHeight,
        {
          stroke: borderColor,
          strokeWidth: sketchStrokeWidth,
          roughness: sketchRoughness,
          bowing: sketchBowing
        }
      );
      legendRect.classList.add('pot-legend-box');
      svg.node().appendChild(legendRect);

      // Draw legend items inside the box
      const boxSize = 12;
      const firstItemY = legendStartY + boxPadding + (boxSize / 2) + 4;

      legendEntries.forEach(([pot, color], idx) => {
        const y = firstItemY + idx * itemHeight;

        // Pot name at left (same column as ingredient names)
        svg.append('text')
          .attr('class', 'pot-legend')
          .attr('x', nameX)
          .attr('y', y)
          .attr('font-size', `${ingredientListFontSize}px`)
          .attr('font-family', 'xkcd Script, cursive')
          .attr('fill', 'var(--text-color)')
          .text(pot);

        // Color swatch at right (render with Rough.js for sketchy style)
        const swX = amountX - boxSize;
        const swY = y - boxSize + 4;
        // Scale down hatch gap and weight for small legend swatches so the
        // sketch fill remains visually balanced.
        const legendGap = Math.max(1, Math.round(voronoiFillGap / 5));
        const legendWeight = Math.max(0.5, voronoiFillWeight / 5);
        const sw = rc.rectangle(swX, swY, boxSize, boxSize, {
          stroke: 'none',
          strokeWidth: 0,
          fill: color,
          fillStyle: voronoiFillStyle,
          hachureGap: legendGap,
          fillWeight: legendWeight,
          roughness: sketchRoughness,
          bowing: sketchBowing
        });
        sw.classList.add('pot-legend-swatch');
        svg.node().appendChild(sw);
      });
    }
  }
  
  // Function to display instructions in top-right quadrant
  function displayInstructions() {
    // No instructions to display, only title
  }

  // Function to update generate button state
  function updateGenerateButtonState() {
    const input = (document.getElementById('recipe-input') as HTMLTextAreaElement).value;
    const button = document.getElementById('generate-flowchart') as HTMLButtonElement;
    const hasContent = input.trim().length > 0;
    
    button.disabled = !hasContent;
    if (!hasContent) {
      button.classList.add('opacity-50', 'cursor-not-allowed');
      button.classList.remove('hover:bg-blue-600');
    } else {
      button.classList.remove('opacity-50', 'cursor-not-allowed');
      button.classList.add('hover:bg-blue-600');
    }
  }

  // Set up button handlers
  const recipeInput = document.getElementById('recipe-input') as HTMLTextAreaElement;
  
  // Update button state on input
  recipeInput.addEventListener('input', updateGenerateButtonState);
  
  // Initial button state check
  updateGenerateButtonState();
  
  document.getElementById('generate-flowchart')!.addEventListener('click', () => {
    const input = recipeInput.value;
    if (input.trim()) {
      initSVG();
      const parsedRecipe = parseRecipe(input);
      renderFlowchart(parsedRecipe.graphData);
      displayIngredients(parsedRecipe.ingredients);
      displayInstructions();
    }
  });

  document.getElementById('save-svg')!.addEventListener('click', () => {
    const svgElement = document.querySelector('#recipe-flowchart svg') as SVGSVGElement;
    if (!svgElement) return;
    
    // Clone the SVG to avoid modifying the original
    const svgClone = svgElement.cloneNode(true) as SVGSVGElement;
    
    // Get the SVG markup
    const svgData = new XMLSerializer().serializeToString(svgClone);
    
    // Create a blob and download
    const blob = new Blob([svgData], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'recipe-flowchart.svg';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  });
  
  // Helper: rasterize an SVG element into a canvas (returns Promise<HTMLCanvasElement>)
  function exportSVGToCanvas(svgElement: SVGSVGElement, scale = (window.devicePixelRatio || 1)) {
    return new Promise<HTMLCanvasElement>((resolve, reject) => {
      // Clone to avoid mutating original
      const svgClone = svgElement.cloneNode(true) as SVGSVGElement;

      // Determine intrinsic size from viewBox if available
      const vb = svgElement.viewBox && svgElement.viewBox.baseVal;
      const intrinsicWidth = (vb && vb.width) ? vb.width : (svgElement.clientWidth || width);
      const intrinsicHeight = (vb && vb.height) ? vb.height : (svgElement.clientHeight || height);

      svgClone.setAttribute('width', String(intrinsicWidth));
      svgClone.setAttribute('height', String(intrinsicHeight));

      const serialized = new XMLSerializer().serializeToString(svgClone);
      const blob = new Blob([serialized], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const img = new Image();

      img.onload = () => {
        try {
          const canvas = document.createElement('canvas');
          canvas.width = Math.round(intrinsicWidth * scale);
          canvas.height = Math.round(intrinsicHeight * scale);
          const ctx = canvas.getContext('2d');
          if (!ctx) throw new Error('Could not get canvas context');
          // Scale so image renders crisply on high-DPI screens
          ctx.setTransform(scale, 0, 0, scale, 0, 0);
          ctx.drawImage(img, 0, 0);
          URL.revokeObjectURL(url);
          resolve(canvas);
        } catch (err) {
          URL.revokeObjectURL(url);
          reject(err);
        }
      };

      img.onerror = (e) => {
        URL.revokeObjectURL(url);
        reject(e);
      };

      // Use a data URL for CORS-safe rendering when possible
      img.src = url;
    });
  }

  // Download as PNG
  async function downloadPNG(svgElement: SVGSVGElement) {
    try {
      const canvas = await exportSVGToCanvas(svgElement);
      canvas.toBlob((blob) => {
        if (!blob) return;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'recipe-flowchart.png';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }, 'image/png');
    } catch (err) {
      // Fallback: download SVG if rasterization fails
      console.error('PNG export failed, falling back to SVG:', err);
      const blob = new Blob([new XMLSerializer().serializeToString(svgElement)], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'recipe-flowchart.svg';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }
  }

  

  // Wire up new buttons
  document.getElementById('save-png')!.addEventListener('click', async () => {
    const svgElement = document.querySelector('#recipe-flowchart svg') as SVGSVGElement;
    if (!svgElement) return;
    await downloadPNG(svgElement);
  });
  
  // Pots toggle: hide/show voronoi background and legend
  const togglePotsEl = document.getElementById('toggle-pots') as HTMLInputElement | null;
  if (togglePotsEl) {
    togglePotsEl.addEventListener('change', (e) => {
      showPots = !!(togglePotsEl && togglePotsEl.checked);
      if (!showPots) {
        try {
          // remove any voronoi shapes and legend items
          voronoiGroup.selectAll('.voronoi-rough').remove();
        } catch (err) { }
        svg.selectAll('.pot-legend').remove();
        svg.selectAll('.pot-legend-box').remove();
        svg.selectAll('.pot-legend-swatch').remove();
      } else {
        // Re-render the flowchart (cheap) so Voronoi and legend are recomputed
        try {
          renderFlowchart(currentData);
          displayIngredients(lastIngredients || []);
        } catch (err) { /* non-fatal */ }
      }
    });
  }

</script>

<style>
  @font-face {
    font-family: "xkcd Script";
    src: url("/fonts/xkcd-script.woff") format("woff");
    font-weight: normal;
    font-style: normal;
    font-display: swap;
  }

  #recipe-flowchart {
    border: 0px solid #e5e7eb;
    border-radius: 0.5rem;
    background: transparent;
    overflow: hidden;
    
    --arrow-color: #666;
    --link-color: #666;
    --text-color: #1f2937;
    --text-muted: #6b7280;
    --output-fill: rgba(13, 102, 255, 0.5);
  }
  
  #recipe-flowchart text {
    font-family: "xkcd Script", cursive;
  }
  
  :global(.dark) #recipe-flowchart {
    background: transparent;
    
    --arrow-color: #9ca3af;
    --link-color: #9ca3af;
    --node-stroke: #e5e7eb;
    --text-color: #f3f4f6;
    --text-muted: #9ca3af;
    --output-fill: rgba(156, 163, 175, 0.15);
    --border-color: #e5e7eb;
  }
</style>
