---
import initPositions from './init.json';
// AI Notice: Mainly vibecoded
// TODO: Refactor to separate JS logic into its own file for better maintainability
---

<div class="my-8">
  <div class="mb-4">
    <label for="recipe-input" class="block text-sm font-medium mb-2">
      Enter a recipe (one step per line):
    </label>
    <textarea
      id="recipe-input"
      rows="8"
      class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-800 dark:text-gray-100 font-mono text-sm"
      placeholder="Add PO-TA-TOES
Boil 'em
Mash 'em
Stick 'em in a stew
Out"
    ></textarea>
    <div class="flex flex-col gap-2 mt-2">
      <div class="flex gap-2 items-center justify-between">
        <button
          id="generate-flowchart"
          class="button  px-1.5"
        >
          Generate Flowchart
        </button>
        <label class="flex items-center gap-2 text-sm">
          <input type="checkbox" id="toggle-pots" checked />
          <span>Show cookware</span>
        </label>
        <button
          id="toggle-theme"
          class="button px-1.5"
          type="button"
        >
          Switch to Light Mode
        </button>
      </div>
      <div class="flex gap-2 justify-center items-center">
        <button
          id="save-svg"
          class="button  px-1.5"
        >
          Save as SVG
        </button>
        <button
          id="save-png"
          class="button  px-1.5"
        >
          Save as PNG
        </button>
        <label class="flex items-center gap-2 text-sm">
          <input type="checkbox" id="png-white-bg" />
          <span>Transparent background</span>
        </label>
        <button
          id="share-recipe"
          class="button  px-1.5"
          title="Copy shareable link"
        >
          Share Recipe
        </button>
      </div>
    </div>
  </div>
  <div id="recipe-flowchart" data-init={JSON.stringify(initPositions)}></div>
</div>

<script>
  import * as d3 from 'd3';
  import rough from 'roughjs';
  import * as ClipperLib from 'clipper-lib';


  // Type definitions
  type NodeGroup = 'ingredient' | 'process' | 'output';
  
  interface Node {
    id: string;
    label: string;
    group: NodeGroup;
    x?: number;
    y?: number;
    fx?: number | null;
    fy?: number | null;
  }
  
  interface Link {
    source: string | Node;
    target: string | Node;
  }
  
  interface GraphData {
    nodes: Node[];
    links: Link[];
  }

  interface Ingredient {
    name: string;
    amount: string;
  }

  // Default recipe data
  const defaultRecipeData: GraphData = {
    nodes: [
      // Ingredients
      { id: "eggs", label: "2 Eggs", group: "ingredient" },
      { id: "butter", label: "Butter", group: "ingredient" },
      { id: "salt", label: "Salt", group: "ingredient" },
      { id: "pepper", label: "Pepper", group: "ingredient" },
      
      // Processes
      { id: "crack", label: "Crack eggs", group: "process" },
      { id: "whisk", label: "Whisk", group: "process" },
      { id: "heat", label: "Heat pan", group: "process" },
      { id: "melt", label: "Melt butter", group: "process" },
      { id: "pour", label: "Pour eggs", group: "process" },
      { id: "scramble", label: "Scramble (2 min)", group: "process" },
      { id: "season", label: "Season", group: "process" },
      
      // Output
      { id: "serve", label: "Serve", group: "output" }
    ],
    links: [
      { source: "eggs", target: "crack" },
      { source: "crack", target: "whisk" },
      { source: "whisk", target: "pour" },
      { source: "butter", target: "heat" },
      { source: "heat", target: "melt" },
      { source: "melt", target: "pour" },
      { source: "pour", target: "scramble" },
      { source: "scramble", target: "season" },
      { source: "salt", target: "season" },
      { source: "pepper", target: "season" },
      { source: "season", target: "serve" }
    ]
  };

  // Optional titles (can be overridden by recipe front-matter fences)
  let ingredientTitle = "Ingredients";
  let instructionTitle = "Instructions";
  let author = "";
  let date = "";
  let title = "";
  let comment = "";

  let currentData: GraphData = defaultRecipeData;
  let svg: any, simulation: any, link: any, node: any, linkGroup: any, nodeGroup: any;
  let voronoiGroup: any;
  let potColorMapGlobal: Map<string,string> = new Map();
  let rc: any; // Rough.js renderer

  const width = 700;
  const baseHeight = 800;
  let height = baseHeight; // Will be adjusted based on titleOffset
  const nodeRadius = 40;
  const rectWidthMultiplier = 2.4;
  const rectHeightMultiplier = 1.2;
  const rectPadding = 5; // Gap between rectangle edge and links
  const arrowSize = 5;
  const linkDistance = 140;
  const nodeRepulsion = -800;
  // Grid attractor settings (keeps process nodes aligned to a regular grid)
  const gridX = 100; // horizontal grid spacing (px)
  const gridY = 150; // vertical grid spacing (px)
  const gridAttractorStrength = 0.75; // how strongly nodes are pulled toward the grid (0-1)
  
  // Font sizes
  const titleFontSize = 24;
  const nodeFontSize = 16;
  const nodeSubtextFontSize = 14;
  const ingredientListFontSize = 16;
  
  // Quadrant dimensions
  const topRowHeight = 40;
  let titleOffset = 0; // Additional offset when title is present (calculated dynamically)
  const leftColumnWidth = width / 4; // 1 part
  const rightColumnWidth = (width * 3) / 4; // 3 parts
  const quadrantHeight = height - topRowHeight;
  const quadrantPadding = 4; // Padding for quadrant rectangles
  const voronoiPadding = 10; // Inset Voronoi cells from flowchart edges
  const voronoiRounding = 50; // Corner rounding radius for Voronoi cells (px)
  const voronoiInsetPad = 10; // Pixels to inset merged Voronoi cells after union (positive -> shrink)
  const voronoiMergePadStart = 0; // Starting padding (px) when attempting unions
  const voronoiMergeAttempts = 5; // Number of times to retry union (doubling padding each attempt)
  
  // Rough.js sketch style parameters
  const sketchStrokeWidth = 1;
  const sketchRoughness = 1.5;
  const sketchBowing = 1.5;
  const sketchFillStyle = 'zigzag'; // Fill style for output nodes: 'hachure', 'solid', 'zigzag', 'cross-hatch', 'dots', 'dashed', 'zigzag-line'
  // Voronoi rough fill: prefer hachure (parallel hatch lines). Adjust gap/weight for thicker lines.
  const voronoiFillStyle = 'zigzag'; // 'hachure' draws parallel lines (good for thick-line fill)
  const voronoiFillGap = 16; // Distance between hatch lines (px). Lower = denser lines.
  const voronoiFillWeight = 4; // Line weight for hatch strokes (px)
  const voronoiFillOpacity = 0.2; // Opacity for Voronoi fill strokes
  
  // Toggle options
  const showFlowchartBorder = false; // Set to true to show border around flowchart quadrant
  let showPots = true; // Toggle to render pot Voronoi regions and legend

  // Keep last ingredients so toggle can re-render legend without reparsing
  let lastIngredients: Ingredient[] = [];

  // Cache for the embedded font data URL
  let cachedFontDataUrl: string | null = null;

  // Color scale for different node types
  const colorScale = d3.scaleOrdinal()
    .domain(["ingredient", "process", "output"])
    .range(["#93c5fd", "#fcd34d", "#86efac"]);

  function initSVG() {
    d3.select("#recipe-flowchart").selectAll("*").remove();
    
    // Create SVG
    svg = d3.select("#recipe-flowchart")
      .append("svg")
      .attr("width", "100%")
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr("style", "max-width: 100%; height: auto;");

    // Initialize Rough.js
    rc = rough.svg(svg.node());

    // Add title blocks
    // Top-left: Ingredients
    svg.append("text")
      .attr("x", leftColumnWidth / 2)
      .attr("y", 28 + titleOffset)
      .attr("text-anchor", "middle")
      .attr("font-size", `${titleFontSize}px`)
      .attr("font-family", "xkcd Script, cursive")
      .attr("font-weight", "bold")
      .attr("fill", "var(--text-color)")
      .text(ingredientTitle);
    
    // Top-right: Instructions
    svg.append("text")
      .attr("x", leftColumnWidth + rightColumnWidth / 2)
      .attr("y", 28 + titleOffset)
      .attr("text-anchor", "middle")
      .attr("font-size", `${titleFontSize}px`)
      .attr("font-family", "xkcd Script, cursive")
      .attr("font-weight", "bold")
      .attr("fill", "var(--text-color)")
      .text(instructionTitle);

    // Get computed border color and node stroke color
    const borderColor = 'currentColor';
    const nodeStrokeColor = 'currentColor';

    // Draw sketch-style rectangles using Rough.js with dynamic CSS colors
    // Top-left quadrant (Ingredients title)
    const topLeftRect = rc.rectangle(
      quadrantPadding,
      quadrantPadding + titleOffset,
      leftColumnWidth - 2 * quadrantPadding,
      topRowHeight - 2 * quadrantPadding,
      {
        stroke: borderColor,
        strokeWidth: sketchStrokeWidth,
        roughness: sketchRoughness,
        bowing: sketchBowing
      }
    );
    svg.node().appendChild(topLeftRect);

    // Top-right quadrant (Instructions title)
    const topRightRect = rc.rectangle(
      leftColumnWidth + quadrantPadding,
      quadrantPadding + titleOffset,
      rightColumnWidth - 2 * quadrantPadding,
      topRowHeight - 2 * quadrantPadding,
      {
        stroke: borderColor,
        strokeWidth: sketchStrokeWidth,
        roughness: sketchRoughness,
        bowing: sketchBowing
      }
    );
    svg.node().appendChild(topRightRect);

    // Bottom-left quadrant (Ingredients list) - will be updated by displayIngredients
    const bottomLeftRect = rc.rectangle(
      quadrantPadding,
      topRowHeight + quadrantPadding + titleOffset,
      leftColumnWidth - 2 * quadrantPadding,
      quadrantHeight - 2 * quadrantPadding,
      {
        stroke: borderColor,
        strokeWidth: sketchStrokeWidth,
        roughness: sketchRoughness,
        bowing: sketchBowing
      }
    );
    bottomLeftRect.classList.add('ingredients-border');
    svg.node().appendChild(bottomLeftRect);

    // Bottom-right quadrant (Flowchart)
    if (showFlowchartBorder) {
      const bottomRightRect = rc.rectangle(
        leftColumnWidth + quadrantPadding,
        topRowHeight + quadrantPadding + titleOffset,
        rightColumnWidth - 2 * quadrantPadding,
        quadrantHeight - 2 * quadrantPadding,
        {
          stroke: borderColor,
          strokeWidth: sketchStrokeWidth,
          roughness: sketchRoughness,
          bowing: sketchBowing
        }
      );
      svg.node().appendChild(bottomRightRect);
    }

    // Create arrow marker for directed edges with explicit color
    const arrowColor = 'currentColor';
    svg.append("defs").selectAll("marker")
      .data(["arrowhead"])
      .join("marker")
      .attr("id", (d: string) => d)
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 9)
      .attr("refY", 5)
      .attr("markerWidth", arrowSize)
      .attr("markerHeight", arrowSize)
      .attr("orient", "auto-start-reverse")
      .append("path")
      .attr("d", "M 0 0 L 10 5 L 0 10 z")
      .attr("fill", arrowColor)
      .attr("stroke", arrowColor);

    // Create groups for links and nodes (bottom-right quadrant for flowchart)
    // Voronoi background group (rendered first so it's behind links/nodes)
    voronoiGroup = svg.append("g").attr("transform", `translate(${leftColumnWidth}, ${topRowHeight + titleOffset})`).attr('class', 'voronoi-bg');

    linkGroup = svg.append("g").attr("transform", `translate(${leftColumnWidth}, ${topRowHeight + titleOffset})`);
    nodeGroup = svg.append("g").attr("transform", `translate(${leftColumnWidth}, ${topRowHeight + titleOffset})`);
  }

  function renderFlowchart(data: GraphData) {
        // Get node stroke color from CSS variable for current theme
        const nodeStrokeColor = 'currentColor';
    currentData = data;
    
    // Create force simulation (within bottom-right quadrant)
    if (simulation) {
      simulation.stop();
    }
    
    simulation = d3.forceSimulation(data.nodes)
      .force("link", d3.forceLink(data.links)
        .id((d: any) => d.id)
        .distance(linkDistance))
      .force("charge", d3.forceManyBody().strength(nodeRepulsion))
      .force("center", d3.forceCenter(rightColumnWidth / 2, quadrantHeight / 2))
      .force("collision", d3.forceCollide().radius((d: any) => d.group === "ingredient" ? 25 : nodeRadius * Math.max(rectWidthMultiplier, rectHeightMultiplier) / 2))
      .force("x", d3.forceX(rightColumnWidth / 2).strength(0.1))
      .force("y", d3.forceY((d: any) => d.group === "output" ? quadrantHeight - 80 : quadrantHeight / 2).strength((d: any) => d.group === "output" ? 0.5 : 0.1))
      // Grid attractor keeps process nodes visually aligned in columns/rows
      .force("grid", forceGrid(gridX, gridY, gridAttractorStrength))
      // Ingredient grid keeps ingredient nodes aligned in a compact left column
      .force("ingredientGrid", forceIngredientGrid(gridX, gridY, gridAttractorStrength, 0));

    // Apply any stored positions for this graph (by node hash) so matching nodes
    // keep their previous locations when regenerating the chart.
    try { applyStoredPositionsToGraph(data); } catch (e) { }

    // Create links
    linkGroup.selectAll("*").remove();
    const linkColor = 'currentColor';
    link = linkGroup
      .selectAll("line")
      .data(data.links)
      .join("line")
      .attr("stroke", linkColor)
      .attr("stroke-width", 2)
      .attr("color", linkColor)
      .attr("marker-end", "url(#arrowhead)");

    // Create nodes
    nodeGroup.selectAll("*").remove();
    node = nodeGroup
      .selectAll("g")
      .data(data.nodes)
      .join("g")
      .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

    // Create/update Voronoi cells for process nodes — include the final Serve node so it affects cell layout
    // Include all process nodes and any output nodes (final words like "Serve"
    // should also influence Voronoi/pot layout). Previously only an output
    // labelled "Serve" was included; accept any output label now.
    const processNodes = data.nodes.filter((d: Node) =>
      d.group === 'process' || d.group === 'output'
    );

    // Helper: extract pot name from a process label (looks for last " in ")
    const extractPot = (label: string | undefined) => {
      if (!label) return null;
      const idx = label.lastIndexOf(' in ');
      if (idx === -1) return null;
      return label.slice(idx + 4).trim();
    };

    // Escape string for use in RegExp
    const escapeRegExp = (s: string) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    // Build a palette mapped to pot names so colors are stable
    const palette = ['#f97316','#f59e0b','#ef4444','#10b981','#3b82f6','#8b5cf6','#ec4899','#06b6d4','#f43f5e','#a3e635'];
    // Collect pot names, ensure uniqueness, then sort alphabetically so color
    // assignment is deterministic and the legend is ordered.
    const potNames = Array.from(
      new Set(processNodes.map((n: any) => extractPot(n.label)).filter(Boolean))
    ).map(String).sort((a, b) => a.localeCompare(b));
    const potColorMap = new Map<string,string>();
    potNames.forEach((p: any, i: number) => potColorMap.set(p, palette[i % palette.length]));
    // Expose the pot -> color mapping for the legend
    potColorMapGlobal = potColorMap;
    // Helper: build a rounded SVG path from a polygon (quadratic curve at each corner)
    // Default rounding is `voronoiRounding`; rr inside will clamp to edge lengths when needed
    const roundedPathFromPolygon = (poly: [number, number][], r = voronoiRounding) => {
      if (!poly || poly.length === 0) return '';
      const n = poly.length;
      // helper math
      const dist = (a: number[], b: number[]) => Math.hypot(a[0]-b[0], a[1]-b[1]);
      const norm = (a: number[]) => { const L = Math.hypot(a[0], a[1])||1; return [a[0]/L, a[1]/L]; };

      const pA: [number, number][] = new Array(n);
      const pB: [number, number][] = new Array(n);

      for (let i = 0; i < n; i++) {
        const prev = poly[(i - 1 + n) % n];
        const curr = poly[i];
        const next = poly[(i + 1) % n];

        const toPrev = [prev[0] - curr[0], prev[1] - curr[1]] as number[];
        const toNext = [next[0] - curr[0], next[1] - curr[1]] as number[];
        const dPrev = dist(curr, prev);
        const dNext = dist(curr, next);
        const rr = Math.min(r, dPrev / 2, dNext / 2);

        const nPrev = norm(toPrev);
        const nNext = norm(toNext);

        pA[i] = [curr[0] + nPrev[0] * rr, curr[1] + nPrev[1] * rr];
        pB[i] = [curr[0] + nNext[0] * rr, curr[1] + nNext[1] * rr];
      }

      // Build path: move to pB[last], then for each vertex line to pA[i] then quadratic to pB[i] with control at curr
      let d = '';
      const start = pB[(n - 1) % n];
      d += `M ${start[0]} ${start[1]}`;
      for (let i = 0; i < n; i++) {
        const curr = poly[i];
        const a = pA[i];
        const b = pB[i];
        d += ` L ${a[0]} ${a[1]} Q ${curr[0]} ${curr[1]} ${b[0]} ${b[1]}`;
      }
      d += ' Z';
      return d;
    };

    // Grid attractor force: nudges process nodes toward the nearest grid cell.
    // Implemented as a custom d3 force so it participates naturally with other forces.
    function forceGrid(gridX = 140, gridY = 100, strength = 0.2) {
      let nodes: any[] | undefined;
      function force(alpha: number) {
        if (!nodes) return;
        for (const d of nodes) {
          // Only apply to process nodes (keep ingredients and outputs free)
          if (!d || d.group !== 'process') continue;
          if (typeof d.x !== 'number' || typeof d.y !== 'number') continue;

          const gx = Math.round(d.x / gridX) * gridX;
          const gy = Math.round(d.y / gridY) * gridY;

          // Apply a small velocity change toward the grid point. Scale with alpha.
          d.vx = (d.vx || 0) + (gx - d.x) * strength * alpha;
          d.vy = (d.vy || 0) + (gy - d.y) * strength * alpha;
        }
      }
      force.initialize = function(_nodes: any[]) { nodes = _nodes; };
      return force;
    }

    // Ingredient grid force: gently aligns ingredient nodes to a narrow
    // column grid near the left side of the flowchart area so they are
    // visually ordered and avoid overlapping links.
    function forceIngredientGrid(gridX = 80, gridY = 80, strength = 0.6, offsetX = 40) {
      let nodes: any[] | undefined;
      function force(alpha: number) {
        if (!nodes) return;
        for (const d of nodes) {
          if (!d || d.group !== 'ingredient') continue;
          if (typeof d.x !== 'number' || typeof d.y !== 'number') continue;

          // Compute nearest grid cell within the ingredient column region
          const gx = Math.round((d.x - offsetX) / gridX) * gridX + offsetX;
          const gy = Math.round(d.y / gridY) * gridY;

          // Apply a mild velocity toward the grid cell scaled by alpha
          d.vx = (d.vx || 0) + (gx - d.x) * strength * alpha;
          d.vy = (d.vy || 0) + (gy - d.y) * strength * alpha;
        }
      }
      force.initialize = function(_nodes: any[]) { nodes = _nodes; };
      return force;
    }

    // Add rounded rectangles to nodes (only for non-ingredient nodes)
    node.filter((d: Node) => d.group !== "ingredient")
      .each(function(this: SVGGElement, d: Node) {
        const g = d3.select(this);
        const rectWidth = nodeRadius * rectWidthMultiplier;
        const rectHeight = nodeRadius * rectHeightMultiplier;
        const x = -rectWidth / 2;
        const y = -rectHeight / 2;

        // Get stroke and fill color based on node type and current theme
        const strokeColor = nodeStrokeColor;
        const fillColor = d.group === "output" ? 'rgba(0, 91, 249, 0.2)' : 'none';

        // Create rough rectangle
        const roughRect = rc.rectangle(x, y, rectWidth, rectHeight, {
          stroke: strokeColor,
          strokeWidth: sketchStrokeWidth,
          fill: fillColor,
          fillStyle: d.group === "output" ? sketchFillStyle : 'solid',
          roughness: sketchRoughness,
          bowing: sketchBowing
        });

        this.appendChild(roughRect);
        roughRect.style.cursor = 'grab';
      });

    // Add invisible overlay for process nodes to make them draggable
    node.filter((d: Node) => d.group === "process")
      .append("rect")
      .attr("x", -nodeRadius * rectWidthMultiplier / 2)
      .attr("y", -nodeRadius * rectHeightMultiplier / 2)
      .attr("width", nodeRadius * rectWidthMultiplier)
      .attr("height", nodeRadius * rectHeightMultiplier)
      .attr("fill", "transparent")
      .attr("stroke", "none")
      .style("cursor", "grab");

      // Add invisible overlay for output nodes to keep them draggable (for filled/sketch style nodes)
      node.filter((d: Node) => d.group === "output")
        .append("rect")
        .attr("x", -nodeRadius * rectWidthMultiplier / 2)
        .attr("y", -nodeRadius * rectHeightMultiplier / 2)
        .attr("width", nodeRadius * rectWidthMultiplier)
        .attr("height", nodeRadius * rectHeightMultiplier)
        .attr("fill", "transparent")
        .attr("stroke", "none")
        .style("cursor", "grab");

    // Add invisible larger circle for ingredient nodes to make them draggable
    node.filter((d: Node) => d.group === "ingredient")
      .append("circle")
      .attr("r", 20)
      .attr("fill", "transparent")
      .attr("stroke", "none")
      .style("cursor", "grab");

    // Add labels to nodes
    node.append("text")
      .attr("text-anchor", "middle")
      .attr("dy", "0.3em")
      .attr("font-size", `${nodeFontSize}px`)
      .attr("font-family", "xkcd Script, cursive")
      .attr("fill", "var(--text-color)")
      .style("pointer-events", "none")
      .style("user-select", "none")
      .each(function(this: SVGTextElement, d: Node) {
        const text = d3.select(this);

        // Compute a display label that strips the trailing " in <pot>" while preserving parenthetical clarification
        const raw = d.label || '';
        const pot = extractPot(raw);
        const displayLabel = pot ? raw.replace(new RegExp(`\\s+in\\s+${escapeRegExp(pot)}\\s*$`), '').trim() : raw;

        // Check for clarification in brackets on the display label
        const bracketMatch = displayLabel.match(/^(.+?)\s*\(([^)]+)\)$/);

        if (bracketMatch) {
          const mainText = bracketMatch[1].trim();
          const clarification = bracketMatch[2].trim();

          text.append("tspan")
            .attr("x", 0)
            .attr("dy", "-0.3em")
            .text(mainText);
          text.append("tspan")
            .attr("x", 0)
            .attr("dy", "1.2em")
            .attr("font-size", `${nodeSubtextFontSize}px`)
            .attr("fill", "var(--text-muted)")
            .text(`(${clarification})`);
        } else {
          const words = displayLabel.split(" ");
          if (words.length === 1) {
            text.text(displayLabel);
          } else {
            text.append("tspan")
              .attr("x", 0)
              .attr("dy", "-0.3em")
              .text(words.slice(0, -1).join(" "));
            text.append("tspan")
              .attr("x", 0)
              .attr("dy", "1.2em")
              .text(words[words.length - 1]);
          }
        }
      });

    // Update positions on simulation tick
    simulation.on("tick", () => {
      // Constrain node positions within quadrant bounds
      data.nodes.forEach((d: Node) => {
        const margin = d.group === "ingredient" ? 30 : nodeRadius * Math.max(rectWidthMultiplier, rectHeightMultiplier) / 2 * 1.2;
        d.x = Math.max(margin, Math.min(rightColumnWidth - margin, d.x ?? 0));
        d.y = Math.max(margin, Math.min(quadrantHeight - margin, d.y ?? 0));
      });

      // Update Voronoi polygons based on current process node positions
      if (showPots) {
      try {
        // Ensure the points array is typed as an array of number tuples so
        // TypeScript accepts it for d3.Delaunay.from
        const points: Array<[number, number]> = processNodes.map((n: any) => [n.x ?? 0, n.y ?? 0] as [number, number]);
        if (points.length > 0) {
          const delaunay = d3.Delaunay.from(points);
          const voronoi = delaunay.voronoi([
            voronoiPadding,
            voronoiPadding,
            rightColumnWidth - voronoiPadding,
            quadrantHeight - voronoiPadding
          ]);

          // Remove previous rough Voronoi shapes
          voronoiGroup.selectAll('.voronoi-rough').remove();

          // Group Voronoi cells by pot so neighbouring cells of the same pot can be drawn as one shape
          const cellsByPot = new Map<string, Array<[number, number][]>>();
          processNodes.forEach((n: any, i: number) => {
            const cell = voronoi.cellPolygon(i);
            if (!cell || cell.length === 0) return;
            const pot = extractPot(n.label);
            if (!pot) return;
            if (!cellsByPot.has(pot)) cellsByPot.set(pot, []);
            cellsByPot.get(pot)!.push(cell as [number, number][]);
          });

          // For each pot, concatenate rounded paths and draw once with Rough.js (fill-only, no stroke)
          cellsByPot.forEach((polys, pot) => {
            const hex = potColorMap.get(pot) || palette[0];
            const fillCol = d3.color(hex);
            if (fillCol) fillCol.opacity = voronoiFillOpacity;

            const rounding = voronoiRounding;

            // Attempt to union neighbouring polygons for this pot so we can
            // stroke/round the outer boundary once. Fall back to simple
            // concatenation if union fails.
            let combinedPath = '';
            try {
              // Expand each polygon slightly so neighbouring cells overlap
              // and `polygon-clipping.union` has a better chance to merge them.
              // Use Clipper to produce a robust outward offset of each polygon
              // before unioning. Clipper works with integer coordinates, so scale
              // geometry by `clipperScale` then scale back.
              const clipperScale = 100; // scale factor for integer Clipper coordinates

              const offsetPolygonWithClipper = (ring: [number, number][], pad: number) => {
                if (!ring || ring.length === 0) return ring;
                try {
                  const co = new (ClipperLib as any).ClipperOffset();
                  const path = ring.map(([x, y]) => ({ X: Math.round(x * clipperScale), Y: Math.round(y * clipperScale) }));
                  // Close path if necessary
                  if (path.length > 0) {
                    const first = path[0];
                    const last = path[path.length - 1];
                    if (first.X !== last.X || first.Y !== last.Y) path.push({ X: first.X, Y: first.Y });
                  }
                  co.AddPath(path, (ClipperLib as any).JoinType.jtRound, (ClipperLib as any).EndType.etClosedPolygon);
                  const solution = new (ClipperLib as any).Paths();
                  co.Execute(solution, pad * clipperScale);
                  if (solution && solution.length > 0) {
                    // Return the first resulting path as array of [x,y]
                    const out = solution[0].map((pt: any) => [pt.X / clipperScale, pt.Y / clipperScale] as [number, number]);
                    return out;
                  }
                } catch (e) {
                  // fall through to return original ring
                }
                return ring;
              };

              const closeRing = (ring: [number, number][]) => {
                if (!ring || ring.length === 0) return ring;
                const first = ring[0];
                const last = ring[ring.length - 1];
                if (first[0] !== last[0] || first[1] !== last[1]) {
                  return [...ring, [first[0], first[1]]];
                }
                return ring;
              };

              // Try union with increasing padding if initial attempt yields no merged polygons.
              const tryUnionWithPadding = (polysArr: [number, number][][], startPad: number, maxAttempts = voronoiMergeAttempts) => {
                let pad = startPad;
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                  try {
                    const expanded = polysArr.map(p => closeRing(offsetPolygonWithClipper(p, pad)));
                    const args = expanded.map(p => [p]);
                    // First try Clipper union (robust integer boolean ops)
                    let result: any = null;
                    try {
                      const c = new (ClipperLib as any).Clipper();
                      const subj = (expanded as any).map((ring: any) =>
                        (ring as any).map((p: any) => ({ X: Math.round(p[0] * clipperScale), Y: Math.round(p[1] * clipperScale) }))
                      );
                      c.AddPaths(subj, (ClipperLib as any).PolyType.ptSubject, true);
                      const sol = new (ClipperLib as any).Paths();
                      const succeeded = c.Execute((ClipperLib as any).ClipType.ctUnion, sol, (ClipperLib as any).PolyFillType.pftNonZero, (ClipperLib as any).PolyFillType.pftNonZero);
                      if (succeeded && sol && sol.length > 0) {
                        // Convert Paths -> polygon-clipping like structure: array of polygons, each polygon is array of rings
                        result = sol.map((path: any) => [path.map((pt: any) => [pt.X / clipperScale, pt.Y / clipperScale])]);
                      }
                    } catch (e) {
                      // ignore and try polygon-clipping as fallback
                    }

                    // No polygon-clipping fallback: rely on Clipper's union result.
                    // If Clipper couldn't produce a union, leave `result` as null
                    // and fall back to the convex-hull/concatenation logic below.

                    if (result && result.length > 0) return result;
                  } catch (e) {
                    // ignore and increase padding
                  }
                  pad *= 2;
                }
                return null;
              };

              const unionResult = tryUnionWithPadding(polys, voronoiMergePadStart, voronoiMergeAttempts);
              if (!unionResult) {
                // union failed; skip inset step
              }
              if (unionResult && unionResult.length > 0) {
                // unionResult is an array of polygons; each polygon is an array of rings
                // Optionally inset (shrink) the merged polygons by `voronoiInsetPad`.
                let finalPolys: any = unionResult;
                if (typeof voronoiInsetPad === 'number' && voronoiInsetPad > 0) {
                  try {
                    const insetAttempt = unionResult.map((poly: any) => {
                      return poly.map((ring: [number, number][]) => {
                        const inset = offsetPolygonWithClipper(ring, -voronoiInsetPad);
                        // If inset produced a valid polygon (>=3 points), use it; otherwise keep original ring
                        if (inset && inset.length >= 3) return inset;
                        return ring;
                      });
                    }).filter((p: any) => p && p.length > 0);

                    if (insetAttempt && insetAttempt.length > 0) {
                      finalPolys = insetAttempt;
                    }
                  } catch (e) {
                    // If inset fails for any reason, fall back to the original union result
                    finalPolys = unionResult;
                  }
                }

                combinedPath = finalPolys.map((poly: any) => {
                  // For each ring in the polygon (outer ring + holes) create a rounded path
                  return poly.map((ring: [number, number][]) => roundedPathFromPolygon(ring, rounding)).join(' ');
                }).join(' ');
              } else {
                // Fallback: if union failed, build a convex hull of all vertices
                const allPoints: [number, number][] = [];
                polys.forEach(p => p.forEach(pt => allPoints.push([pt[0], pt[1]] as [number, number])));

                const convexHull = (pts: [number, number][]) => {
                  if (!pts || pts.length === 0) return [] as [number, number][];
                  // Unique points
                  const map = new Map<string, [number, number]>();
                  for (const p of pts) map.set(p[0] + ',' + p[1], p);
                  const uniq = Array.from(map.values());
                  if (uniq.length <= 2) return uniq;
                  uniq.sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);
                  const cross = (o: [number, number], a: [number, number], b: [number, number]) => (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0]);
                  const lower: [number, number][] = [];
                  for (const p of uniq) {
                    while (lower.length >= 2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop();
                    lower.push(p);
                  }
                  const upper: [number, number][] = [];
                  for (let i = uniq.length - 1; i >= 0; i--) {
                    const p = uniq[i];
                    while (upper.length >= 2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop();
                    upper.push(p);
                  }
                  upper.pop(); lower.pop();
                  const hull = lower.concat(upper);
                  return hull.length ? hull : uniq;
                };

                const hull = convexHull(allPoints);
                if (hull && hull.length > 0) {
                  // Try insetting the convex hull as well
                  try {
                    const insetHull = offsetPolygonWithClipper(hull, -voronoiInsetPad);
                    if (insetHull && insetHull.length >= 3) {
                      combinedPath = roundedPathFromPolygon(insetHull, rounding);
                    } else {
                      combinedPath = roundedPathFromPolygon(hull, rounding);
                    }
                  } catch (e) {
                    combinedPath = roundedPathFromPolygon(hull, rounding);
                  }
                } else {
                  combinedPath = polys.map(p => roundedPathFromPolygon(p, rounding)).join(' ');
                }
              }
            } catch (err) {
              // If polygon union fails for any reason, fall back to concatenating
              // the individual rounded polygons so we still render something.
              combinedPath = polys.map(p => roundedPathFromPolygon(p, rounding)).join(' ');
            }

            // Draw Voronoi region with Rough.js for sketchy look. If Rough fails,
            // fall back to plain SVG path so rendering still occurs.
            try {
              // Build an RGBA color string that includes the voronoiFillOpacity
              const d3col = d3.color(hex);
              const fillWithAlpha = d3col
                ? `rgba(${Math.round((d3col as any).r)},${Math.round((d3col as any).g)},${Math.round((d3col as any).b)},${voronoiFillOpacity})`
                : hex;

              // Render with Rough.js using hachure fill and no outline stroke so
              // regions are represented by thick parallel hatch lines.
              const roughPath = (rc as any).path(combinedPath, {
                // Remove outline by disabling stroke
                stroke: 'none',
                strokeWidth: 0,
                // Fill using the voronoiFillStyle (hachure) and color (includes alpha)
                fill: fillWithAlpha,
                fillStyle: voronoiFillStyle,
                // Control density/weight of hatch lines for a thicker appearance
                hachureGap: voronoiFillGap,
                fillWeight: voronoiFillWeight,
                roughness: sketchRoughness,
                bowing: sketchBowing
              }) as SVGElement;
              roughPath.classList.add('voronoi-rough');
              roughPath.setAttribute('fill-rule', 'evenodd');
              roughPath.style.pointerEvents = 'none';
              // Append the Rough.js-generated node into the voronoi group
              voronoiGroup.node().appendChild(roughPath);
            } catch (e) {
              // Fallback to plain SVG path without outline (fill-only)
              const d3col = d3.color(hex);
              const fillWithAlpha = d3col
                ? `rgba(${Math.round((d3col as any).r)},${Math.round((d3col as any).g)},${Math.round((d3col as any).b)},${voronoiFillOpacity})`
                : hex;

              voronoiGroup.append('path')
                .attr('class', 'voronoi-rough')
                .attr('d', combinedPath)
                .attr('fill', fillWithAlpha)
                .attr('fill-rule', 'evenodd')
                .attr('stroke', 'none')
                .attr('stroke-width', 0)
                .style('pointer-events', 'none');
            }
          });
        }
      } catch (e) {
        // Voronoi calculation can fail briefly while nodes are NaN during simulation start; ignore
      }
      } else {
        // If pots are disabled, ensure voronoi background is cleared
        try { voronoiGroup.selectAll('.voronoi-rough').remove(); } catch (e) { }
      }
      
      link.each(function(this: SVGLineElement, d: any) {
        const dx = d.target.x - d.source.x;
        const dy = d.target.y - d.source.y;
        const dr = Math.sqrt(dx * dx + dy * dy);
        
        // Function to calculate intersection with rectangle edge
        const getRectEdgePoint = (centerX: number, centerY: number, toX: number, toY: number, isIngredient: boolean) => {
          if (isIngredient) {
            // For ingredients, use simple offset
            const offset = 20;
            return {
              x: centerX + ((toX - centerX) * offset) / dr,
              y: centerY + ((toY - centerY) * offset) / dr
            };
          }
          
          // For rectangles
          const rectWidth = nodeRadius * rectWidthMultiplier;
          const rectHeight = nodeRadius * rectHeightMultiplier;
          const angle = Math.atan2(toY - centerY, toX - centerX);
          
          // Check which edge the line intersects
          const absAngle = Math.abs(angle);
          const cornerAngle = Math.atan2(rectHeight, rectWidth);
          
          let edgeX, edgeY;
          if (absAngle < cornerAngle) {
            // Right edge
            edgeX = centerX + (rectWidth / 2 + rectPadding);
            edgeY = centerY + (edgeX - centerX) * Math.tan(angle);
          } else if (absAngle > Math.PI - cornerAngle) {
            // Left edge
            edgeX = centerX - (rectWidth / 2 + rectPadding);
            edgeY = centerY + (edgeX - centerX) * Math.tan(angle);
          } else if (angle > 0) {
            // Bottom edge
            edgeY = centerY + (rectHeight / 2 + rectPadding);
            edgeX = centerX + (edgeY - centerY) / Math.tan(angle);
          } else {
            // Top edge
            edgeY = centerY - (rectHeight / 2 + rectPadding);
            edgeX = centerX + (edgeY - centerY) / Math.tan(angle);
          }
          
          return { x: edgeX, y: edgeY };
        };
        
        const sourcePoint = getRectEdgePoint(d.source.x, d.source.y, d.target.x, d.target.y, d.source.group === "ingredient");
        const targetPoint = getRectEdgePoint(d.target.x, d.target.y, d.source.x, d.source.y, d.target.group === "ingredient");
        
        d3.select(this)
          .attr("x1", sourcePoint.x)
          .attr("y1", sourcePoint.y)
          .attr("x2", targetPoint.x)
          .attr("y2", targetPoint.y);
      });

      node.attr("transform", (d: Node) => `translate(${d.x},${d.y})`);
    });

    // When the simulation finishes, persist node positions
    simulation.on('end', () => {
      try { saveAllPositionsForCurrentGraph(); } catch (e) { }
    });
  }

  // Drag functions
  function dragstarted(event: any) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }

  function dragged(event: any) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }

  function dragended(event: any) {
    if (!event.active) simulation.alphaTarget(0);
    // Release the node so it can participate normally in the simulation
    event.subject.fx = null;
    event.subject.fy = null;

    // Persist the new position for this node using its hash
    try {
      if (event && event.subject && typeof event.subject.x === 'number' && typeof event.subject.y === 'number') {
        const map = loadPositionMap();
        const h = nodeHashForGraph(event.subject, currentData.nodes, currentData.links);
        map[h] = { x: event.subject.x, y: event.subject.y };
        savePositionMap(map);
      }
    } catch (e) { /* non-fatal */ }
  }

  // Parse recipe text input
  function parseRecipe(text: string): { graphData: GraphData; ingredients: Ingredient[] } {
    // Reset frontmatter variables to defaults
    ingredientTitle = "Ingredients";
    instructionTitle = "Instructions";
    author = "";
    date = "";
    title = "";
    comment = "";
    
    // Support optional front-matter fences at the top of the recipe
    // Example:
    // ---
    // Ingredients: Ingrediënten
    // Instructions: Instructies
    // ---
    let raw = text;
    try {
      if (raw.trim().startsWith('---')) {
        const parts = raw.split(/\r?\n/);
        let endIndex = -1;
        for (let k = 1; k < parts.length; k++) {
          if (parts[k].trim() === '---') { endIndex = k; break; }
        }
        if (endIndex > 0) {
          const fmLines = parts.slice(1, endIndex);
          fmLines.forEach((l) => {
            const m = l.match(/^\s*([^:]+)\s*:\s*(.+)\s*$/);
            if (m) {
              const key = m[1].trim().toLowerCase();
              const val = m[2].trim();
              if (key === 'ingredients') ingredientTitle = val;
              if (key === 'instructions') instructionTitle = val;
              if (key === 'author') author = val;
              if (key === 'date') date = val;
              if (key === 'title') title = val;
              if (key === 'comment') comment = val;
            }
          });
          raw = parts.slice(endIndex + 1).join('\n');
        }
      }
    } catch (e) {
      // ignore malformed front-matter and continue parsing normally
    }

    const lines = raw.trim().split('\n')
      .map(line => {
        // Remove inline comments (// text)
        const commentIndex = line.indexOf('//');
        if (commentIndex !== -1) {
          return line.substring(0, commentIndex);
        }
        return line;
      })
      .filter(line => line.trim());
    
    const nodes: Node[] = [];
    const links: Link[] = [];
    const ingredients: Ingredient[] = [];
    const nodeMap = new Map<string, Node>(); // Track nodes by their content
    const linkSet = new Set<string>(); // Prevent duplicate links
    let nodeId = 0;
    let lastProcessNode: Node | null = null;
    const subprocesses = new Map<string, any[]>(); // Track subprocess outputs
    
    const addLink = (source: string, target: string) => {
      const key = `${source}->${target}`;
      if (!linkSet.has(key)) {
        links.push({ source, target });
        linkSet.add(key);
      }
    };
    
    let i = 0;
    while (i < lines.length) {
      const line = lines[i].trim();
      const lineLower = line.toLowerCase();
      
      // Handle subprocess definition
      if (lineLower.startsWith('subprocess ')) {
        const match = line.match(/subprocess\s+(\w+)/i);
        if (!match) {
          i++;
          continue;
        }
        const subprocessName = match[1];
        const subprocessLines = [];
        i++; // Skip opening brace line
        
        // Collect subprocess lines
        while (i < lines.length && !lines[i].trim().startsWith('}')) {
          const subLine = lines[i].trim();
          if (subLine) subprocessLines.push(subLine);
          i++;
        }
        
        // Process subprocess
        let subLastNode: Node | null = null;
        let subOutputs: any[] = [];
        let pendingSubIngredients: Node[] = [];
        
        subprocessLines.forEach((subLine: string, idx: number) => {
          const subLineLower = subLine.toLowerCase();
          if (subLineLower.startsWith('add ')) {
            let ingredient = subLine.substring(4).trim();
            let amount = '';
            
            // Extract amount in curly braces if present (format: Add ingredient {amount})
            const amountMatch = ingredient.match(/^(.+?)\s*\{([^}]+)\}$/);
            if (amountMatch) {
              ingredient = amountMatch[1].trim();
              amount = amountMatch[2].trim();
            }
            
            // Add to ingredients list if not from a subprocess
            if (!ingredient.includes(' from ')) {
              ingredients.push({ name: ingredient, amount });
            }
            
            // Check if it's from another subprocess
            const fromMatch = ingredient.match(/^(.+?)\s+from\s+(\w+)$/);
            if (fromMatch) {
              const [, outputName, fromSubprocessName] = fromMatch;
              const fromSubOutputs = subprocesses.get(fromSubprocessName) || [];
              
              // Find the matching output from the other subprocess
              let fromSubOutput;
              if (outputName === '.') {
                fromSubOutput = fromSubOutputs[fromSubOutputs.length - 1];
              } else {
                fromSubOutput = fromSubOutputs.find((o: any) => o.name === outputName);
              }
              
              // Add this output node to pending ingredients
              if (fromSubOutput && fromSubOutput.node) {
                pendingSubIngredients.push(fromSubOutput.node);
              }
            } else {
              // Regular ingredient
              if (!nodeMap.has(ingredient)) {
                const id = `node${nodeId++}`;
                const node: Node = { id, label: ingredient, group: "ingredient" };
                nodes.push(node);
                nodeMap.set(ingredient, node);
              }
              const ingredientNode = nodeMap.get(ingredient);
              if (ingredientNode) {
                pendingSubIngredients.push(ingredientNode);
              }
            }
          } else if (subLineLower.startsWith('out ')) {
            const outputName = subLine.substring(4).trim();
            if (subLastNode) {
              // Create an intermediary ingredient node for named outputs
              if (outputName !== '.') {
                const outputId = `node${nodeId++}`;
                const outputNode: Node = { id: outputId, label: outputName, group: "ingredient" };
                nodes.push(outputNode);
                nodeMap.set(`${subprocessName}_${outputName}`, outputNode);
                
                // Link the last subprocess step to the output node
                addLink(subLastNode.id, outputId);
                
                subOutputs.push({ node: outputNode, name: outputName });
              } else {
                // For '.', use the last process node directly
                subOutputs.push({ node: subLastNode, name: '.' });
              }
            }
          } else {
            // Process step
            const id = `node${nodeId++}`;
            const node: Node = { id, label: subLine, group: "process" };
            nodes.push(node);
            
            // Link pending ingredients to this step
            pendingSubIngredients.forEach((ingNode: Node) => {
              addLink(ingNode.id, id);
            });
            pendingSubIngredients = [];
            
            // Link to previous subprocess step
            if (subLastNode) {
              addLink(subLastNode.id, id);
            }
            
            subLastNode = node;
          }
        });
        
        // If no explicit output was defined, use the final node as the default output
        if (subOutputs.length === 0 && subLastNode) {
          subOutputs.push({ node: subLastNode, name: '.' });
        }
        
        // Store subprocess outputs
        subprocesses.set(subprocessName, subOutputs);
        
      } else if (lineLower.startsWith('add ')) {
        let ingredient = line.substring(4).trim();
        let amount = '';
        
        // Extract amount in curly braces if present (format: Add ingredient {amount})
        const amountMatch = ingredient.match(/^(.+?)\s*\{([^}]+)\}$/);
        if (amountMatch) {
          ingredient = amountMatch[1].trim();
          amount = amountMatch[2].trim();
        }
        
        // Add to ingredients list if not from a subprocess
        if (!ingredient.includes(' from ')) {
          ingredients.push({ name: ingredient, amount });
        }
        
        // Check if it's from a subprocess
        const fromMatch = ingredient.match(/^(.+?)\s+from\s+(\w+)$/);
        if (fromMatch) {
          const [, outputName, subprocessName] = fromMatch;
          const subOutputs = subprocesses.get(subprocessName) || [];
          
          // Find the matching output
          let subOutput;
          if (outputName === '.') {
            // '.' refers to the last output of the subprocess
            subOutput = subOutputs[subOutputs.length - 1];
          } else {
            subOutput = subOutputs.find((o: any) => o.name === outputName);
          }
          
          // Find the next process step and link to it
          for (let j = i + 1; j < lines.length; j++) {
            const nextLine = lines[j].trim();
            const nextLineLower = nextLine.toLowerCase();
            if (!nextLineLower.startsWith('add ') && !nextLineLower.startsWith('subprocess ') && !nextLine.startsWith('}')) {
              // This is the next process step, link subprocess output to it
              const nextId = `next_${j}`;
              // We'll link this after we create the node
              if (subOutput) {
                // Store for later linking
                if (!subOutput.pendingLinks) subOutput.pendingLinks = [];
                subOutput.pendingLinks.push(j);
              }
              break;
            }
          }
        } else {
          // Regular ingredient
          if (!nodeMap.has(ingredient)) {
            const id = `node${nodeId++}`;
            const node: Node = { id, label: ingredient, group: "ingredient" };
            nodes.push(node);
            nodeMap.set(ingredient, node);
          }
        }
        
      } else if (line && !line.startsWith('}')) {
        // Check if this is an Out statement at the end (final output)
        if (lineLower.startsWith('out')) {
          const id = `node${nodeId++}`;
          // Use any text following 'Out' as the output label; default to 'Serve'
          // when no label is provided (e.g. a bare 'Out' line).
          let outLabel = line.replace(/^out\s*/i, '').trim();
          if (!outLabel) outLabel = 'Serve';
          const node: Node = { id, label: outLabel, group: "output" };
          nodes.push(node);
          
          // Link from last process step
          if (lastProcessNode) {
            addLink(lastProcessNode.id, id);
          }
          
          // Link subprocess outputs if this is their target
          for (const [subName, outputs] of subprocesses) {
            outputs.forEach((output: any) => {
              if (output.pendingLinks && output.pendingLinks.includes(i)) {
                addLink(output.node.id, id);
              }
            });
          }
          
          // Link any immediately preceding ingredients to this final node
          for (let j = i - 1; j >= 0; j--) {
            const prevLine = lines[j].trim();
            const prevLineLower = prevLine.toLowerCase();
            if (prevLineLower.startsWith('add ') && !prevLine.includes(' from ')) {
              let ingredient = prevLine.substring(4).trim();
              // Remove amount if present
              const amountMatch = ingredient.match(/^(.+?)\s*\{([^}]+)\}$/);
              if (amountMatch) {
                ingredient = amountMatch[1].trim();
              }
              const ingredientNode = nodeMap.get(ingredient);
              if (ingredientNode) {
                addLink(ingredientNode.id, id);
              }
            } else if (!prevLineLower.startsWith('add ')) {
              break;
            }
          }
          
          lastProcessNode = node;
        } else {
          // Process step
          const id = `node${nodeId++}`;
          // If this is the very last line in the top-level recipe, treat it
          // as an output node when the explicit 'Out' keyword is omitted.
          // Otherwise keep it as a process node so earlier steps are not
          // incorrectly themed as outputs.
          const isLastLine = i === lines.length - 1;
          const node: Node = { id, label: line, group: isLastLine ? "output" : "process" };
          nodes.push(node);
          
          // Link to previous process step
          if (lastProcessNode) {
            addLink(lastProcessNode.id, id);
          }
          
          // Link any immediately preceding ingredients to this step (not from subprocess)
          for (let j = i - 1; j >= 0; j--) {
            const prevLine = lines[j].trim();
            const prevLineLower = prevLine.toLowerCase();
            if (prevLineLower.startsWith('add ') && !prevLine.includes(' from ')) {
              let ingredient = prevLine.substring(4).trim();
              // Remove amount if present
              const amountMatch = ingredient.match(/^(.+?)\s*\{([^}]+)\}$/);
              if (amountMatch) {
                ingredient = amountMatch[1].trim();
              }
              const ingredientNode = nodeMap.get(ingredient);
              if (ingredientNode) {
                addLink(ingredientNode.id, id);
              }
            } else if (!prevLineLower.startsWith('add ')) {
              break;
            }
          }
          
          // Link subprocess outputs if this is their target
          for (const [subName, outputs] of subprocesses) {
            outputs.forEach((output: any) => {
              if (output.pendingLinks && output.pendingLinks.includes(i)) {
                addLink(output.node.id, id);
              }
            });
          }
          
          lastProcessNode = node;
        }
      }
      
      i++;
    }
    
    return { graphData: { nodes, links }, ingredients };
  }

    // Compare graph structure (ignoring labels) to decide whether we can
    // preserve node identities (ids/positions) when updating only descriptions.
    function nodeSignature(node: Node, links: Link[]) {
      // signature based on group and connectivity counts
      const inDeg = links.filter((l: Link) => (typeof l.target === 'string' ? l.target : l.target.id) === node.id).length;
      const outDeg = links.filter((l: Link) => (typeof l.source === 'string' ? l.source : l.source.id) === node.id).length;
      return `${node.group}|in:${inDeg}|out:${outDeg}`;
    }

    function graphStructureEqual(oldG: GraphData | null | undefined, newG: GraphData | null | undefined) {
      if (!oldG || !newG) return false;
      if (oldG.nodes.length !== newG.nodes.length) return false;
      if (oldG.links.length !== newG.links.length) return false;

      const oldSigs = oldG.nodes.map((n: Node) => nodeSignature(n, oldG.links)).sort();
      const newSigs = newG.nodes.map((n: Node) => nodeSignature(n, newG.links)).sort();
      // If the multisets of node signatures match, treat structure as same
      for (let i = 0; i < oldSigs.length; i++) if (oldSigs[i] !== newSigs[i]) return false;
      return true;
    }

    // Merge labels from newGraph into oldGraph while preserving ids and positions.
    // This matches nodes by signature and assigns the new label to the matched old id.
    function mergeGraphsPreserveIds(oldG: GraphData, newG: GraphData): GraphData {
      // Build buckets of old nodes by signature
      const sigToOld = new Map<string, Node[]>();
      for (const n of oldG.nodes) {
        const sig = nodeSignature(n, oldG.links);
        if (!sigToOld.has(sig)) sigToOld.set(sig, []);
        sigToOld.get(sig)!.push(n);
      }

      // For each new node, pick an unused old node with same signature
      const used = new Set<string>();
      const mergedNodes: Node[] = newG.nodes.map((n: Node) => {
        const sig = nodeSignature(n, newG.links);
        const candidates = sigToOld.get(sig) || [];
        let match: Node | null = null;
        for (const c of candidates) if (!used.has(c.id)) { match = c; break; }
        if (match) {
          used.add(match.id);
          return { ...match, label: n.label };
        }
        // fallback: keep new node as-is
        return { ...n };
      });

      // Rebuild links but remap any string source/target labels to preserved ids where possible
      const oldLabelToId = new Map<string, string>();
      for (const n of mergedNodes) oldLabelToId.set(n.label, n.id);

      const remap = (ref: string | Node) => {
        if (typeof ref === 'string') {
          // try to find a node with matching label; otherwise keep raw string
          return oldLabelToId.get(ref) || ref;
        }
        return ref.id || ref;
      };

      const mergedLinks: Link[] = newG.links.map((l: Link) => ({ source: remap(l.source) as any, target: remap(l.target) as any }));
      return { nodes: mergedNodes, links: mergedLinks };
    }
  
    // --- Node position persistence using a node hash ---
    // Simple non-cryptographic string hash (deterministic across sessions)
    function simpleHash(s: string) {
      let h = 2166136261 >>> 0;
      for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619) >>> 0;
      }
      return h.toString(36);
    }

    // Compute a stable hash for a node using its label, group and neighbor labels
    function nodeHashForGraph(node: any, nodes: any[], links: any[]) {
      const id = node.id || '';
      const label = (node.label || '').trim();
      const group = node.group || '';

      // Collect neighbor labels for a slightly richer fingerprint
      const incoming = links.filter(l => (typeof l.target === 'string' ? l.target : l.target.id) === id)
        .map(l => {
          const sid = (typeof l.source === 'string' ? l.source : l.source.id);
          const n = nodes.find((x: any) => x.id === sid);
          return n ? (n.label || n.id) : sid;
        }).sort().join('|');
      const outgoing = links.filter(l => (typeof l.source === 'string' ? l.source : l.source.id) === id)
        .map(l => {
          const tid = (typeof l.target === 'string' ? l.target : l.target.id);
          const n = nodes.find((x: any) => x.id === tid);
          return n ? (n.label || n.id) : tid;
        }).sort().join('|');

      const base = `${label}::${group}::in:${incoming}::out:${outgoing}`;
      return simpleHash(base);
    }

    const STORAGE_KEY = 'flowchart-node-positions';

    // Read any build-time initial positions attached to the flowchart container
    const INIT_POSITIONS = (() => {
      try {
        const el = document.getElementById('recipe-flowchart');
        const raw = el ? el.getAttribute('data-init') : null;
        return raw ? JSON.parse(raw) : {};
      } catch (e) { return {}; }
    })();

    // If storage is empty, seed it with the example initial positions so
    // first-time visitors get the same layout as the demo.
    try {
      const existing = localStorage.getItem(STORAGE_KEY);
      if ((!existing || existing === '{}' || existing === 'null') && INIT_POSITIONS && Object.keys(INIT_POSITIONS).length) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(INIT_POSITIONS));
      }
    } catch (e) { /* ignore storage errors */ }

    function loadPositionMap() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return {};
        return JSON.parse(raw || '{}');
      } catch (e) {
        return {};
      }
    }

    function savePositionMap(map: any) {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(map));
      } catch (e) {
        // ignore storage errors
      }
    }

    // Save all current node positions into localStorage using node hashes
    function saveAllPositionsForCurrentGraph() {
      try {
        const map = loadPositionMap();
        if (!currentData || !currentData.nodes) return;
        for (const n of currentData.nodes) {
          if (typeof n.x === 'number' && typeof n.y === 'number') {
            const h = nodeHashForGraph(n, currentData.nodes, currentData.links);
            map[h] = { x: n.x, y: n.y };
          }
        }
        savePositionMap(map);
      } catch (e) { /* non-fatal */ }
    }

    // Attempt to apply stored positions to nodes in a new graph (by hash)
    function applyStoredPositionsToGraph(graph: GraphData) {
      try {
        const map = loadPositionMap();
        if (!graph || !graph.nodes) return;
        for (const n of graph.nodes) {
          const h = nodeHashForGraph(n, graph.nodes, graph.links);
          const p = map[h];
          if (p && typeof p.x === 'number' && typeof p.y === 'number') {
            // Apply stored coordinates but do NOT fix the node in place.
            // Leaving `fx`/`fy` set prevents the node from reacting to
            // forces or to user-driven movements of nearby nodes. Allowing
            // the simulation to move the node keeps the layout responsive.
            n.x = p.x;
            n.y = p.y;
          }
        }
      } catch (e) { /* non-fatal */ }
    }
  // Initialize with stoofvlees recipe
  const stoofvleesRecipe = `---
Title: Flemish Stew
Author: Thomas
Date: 2025
Comment: Based on Jeroen Meus
---

Subprocess Grill {
    Add Meat {1 kg}
    Grill (in butter) in Braising pan
    Out Meat
    Add Beer {2 bottles}
    Cook in Braising pan
    Out Sauce
}

Subprocess Bread {
    Add Bread {1 slice}
    Add Mustard {2 Tb.}
    Smear
    Out .
}

Add Onion {2}
Chop
Sauté (in butter) in Casserole
Add Meat from Grill
Add Sauce from Grill
Add Laurel
Add Thyme
Add Cloves {1}
Add Sirup {1 Tb.}
Add . from Bread
Simmer (on low heat) in Casserole
Add Vinegar
Out `;

  // Preload font asynchronously on page load
  getEmbeddedFontDataUrl().catch(() => {
    // Silently fail - will retry on export if needed
  });

  const parsedRecipe = parseRecipe(stoofvleesRecipe);
  // Set titleOffset based on whether title exists (before initSVG)
  titleOffset = title ? 35 : 0;
  height = baseHeight + titleOffset;
  initSVG();
  // If the structure of the new graph matches the current graph, merge labels
  // into the existing node ids so positions/ids are preserved.
  let initialDataToRender = parsedRecipe.graphData;
  if (graphStructureEqual(currentData, parsedRecipe.graphData)) {
    initialDataToRender = mergeGraphsPreserveIds(currentData, parsedRecipe.graphData);
  }
  renderFlowchart(initialDataToRender);
  displayIngredients(parsedRecipe.ingredients);
  displayInstructions();

  // Function to display ingredients list
  function displayIngredients(ingredients: Ingredient[]) {
    // Remove previous ingredient text, borders and legend
    svg.selectAll(".ingredient-text").remove();
    svg.selectAll(".ingredients-border").remove();
    svg.selectAll(".pot-legend").remove();
    svg.selectAll('.pot-legend-box').remove();
    svg.selectAll('.pot-legend-swatch').remove();
    svg.selectAll('.metadata-text').remove();
    svg.selectAll('.recipe-title').remove();
    
    // Add main title if present
    if (title) {
      svg.append("text")
        .attr("x", width / 2)
        .attr("y", 22)
        .attr("text-anchor", "middle")
        .attr("font-size", "28px")
        .attr("font-family", "xkcd Script, cursive")
        .attr("font-weight", "bold")
        .attr("fill", "var(--text-color)")
        .attr("class", "recipe-title")
        .text(title);
    }

    // remember last ingredients so the pots toggle can re-render the legend
    lastIngredients = ingredients;
    
    const borderColor = 'currentColor';
    
    if (ingredients.length === 0) {
      // Create minimal border when no ingredients
      const minBorder = rc.rectangle(
        quadrantPadding,
        topRowHeight + quadrantPadding + titleOffset,
        leftColumnWidth - 2 * quadrantPadding,
        60,
        { 
          stroke: borderColor,
          strokeWidth: sketchStrokeWidth,
          roughness: sketchRoughness,
          bowing: sketchBowing
        }
      );
      minBorder.classList.add('ingredients-border');
      svg.node().appendChild(minBorder);
      return;
    }
    
    // Remove duplicates by ingredient name and merge amounts
    const uniqueIngredientsMap = new Map<string, Ingredient>();
    ingredients.forEach(ing => {
      const existing = uniqueIngredientsMap.get(ing.name);
      if (existing) {
        // If duplicate found, combine amounts if different
        if (ing.amount && existing.amount !== ing.amount) {
          existing.amount = existing.amount ? `${existing.amount}, ${ing.amount}` : ing.amount;
        } else if (ing.amount && !existing.amount) {
          existing.amount = ing.amount;
        }
      } else {
        uniqueIngredientsMap.set(ing.name, { ...ing });
      }
    });
    
    // Sort ingredients alphabetically
    const sortedIngredients = Array.from(uniqueIngredientsMap.values()).sort((a, b) => 
      a.name.localeCompare(b.name)
    );
    
    // Display in bottom-left quadrant
    const startY = topRowHeight + 40 + titleOffset;
    const lineHeight = 24;
    const nameX = 20;
    const amountX = leftColumnWidth - 20; // Right-aligned position
    
    sortedIngredients.forEach((ing, index) => {
      const yPos = startY + index * lineHeight;
      
      // Remove parenthetical clarifications from ingredient name
      const cleanName = ing.name.replace(/\s*\([^)]*\)/g, '').trim();
      
      // Ingredient name (left-aligned)
      svg.append("text")
        .attr("class", "ingredient-text")
        .attr("x", nameX)
        .attr("y", yPos)
        .attr("font-size", `${ingredientListFontSize}px`)
        .attr("font-family", "xkcd Script, cursive")
        .attr("fill", "var(--text-color)")
        .text(cleanName);
      
      // Amount (right-aligned)
      if (ing.amount) {
        svg.append("text")
          .attr("class", "ingredient-text")
          .attr("x", amountX)
          .attr("y", yPos)
          .attr("text-anchor", "end")
          .attr("font-size", `${ingredientListFontSize}px`)
          .attr("font-family", "xkcd Script, cursive")
          .attr("fill", "var(--text-muted)")
          .text(`(${ing.amount})`);
      }
    });
    
    // Update border height to fit the ingredient list using Rough.js
    const listHeight = sortedIngredients.length * lineHeight + 60;
    const finalHeight = Math.min(listHeight, quadrantHeight - 2 * quadrantPadding);
    
    const newBorder = rc.rectangle(
      quadrantPadding,
      topRowHeight + quadrantPadding + titleOffset,
      leftColumnWidth - 2 * quadrantPadding,
      finalHeight,
      { 
        stroke: borderColor,
        strokeWidth: sketchStrokeWidth,
        roughness: sketchRoughness,
        bowing: sketchBowing
      }
    );
    newBorder.classList.add('ingredients-border');
    svg.node().appendChild(newBorder);

    // Render legend for pots below the ingredient list inside a Rough.js box
    const legendEntries = Array.from(potColorMapGlobal.entries());
    if (showPots && legendEntries.length > 0) {
      const itemHeight = 18;
      const boxPadding = 10;
      const boxX = quadrantPadding;
      const boxWidth = leftColumnWidth - 2 * quadrantPadding;
      const legendStartY = topRowHeight + finalHeight + 12 + titleOffset; // top of legend box

      // Calculate legend box height and clamp to remaining quadrant space
      const legendContentHeight = legendEntries.length * itemHeight + boxPadding * 2;
      const maxAvailable = quadrantHeight - finalHeight - 2 * quadrantPadding;
      const boxHeight = Math.min(legendContentHeight, Math.max(itemHeight + boxPadding * 2, maxAvailable));

      // Draw rough rectangle for legend
      const legendRect = rc.rectangle(
        boxX,
        legendStartY,
        boxWidth,
        boxHeight,
        {
          stroke: borderColor,
          strokeWidth: sketchStrokeWidth,
          roughness: sketchRoughness,
          bowing: sketchBowing
        }
      );
      legendRect.classList.add('pot-legend-box');
      svg.node().appendChild(legendRect);

      // Draw legend items inside the box
      const boxSize = 12;
      const firstItemY = legendStartY + boxPadding + (boxSize / 2) + 4;

      legendEntries.forEach(([pot, color], idx) => {
        const y = firstItemY + idx * itemHeight;

        // Pot name at left (same column as ingredient names)
        svg.append('text')
          .attr('class', 'pot-legend')
          .attr('x', nameX)
          .attr('y', y)
          .attr('font-size', `${ingredientListFontSize}px`)
          .attr('font-family', 'xkcd Script, cursive')
          .attr('fill', 'var(--text-color)')
          .text(pot);

        // Color swatch at right (render with Rough.js for sketchy style)
        const swX = amountX - boxSize;
        const swY = y - boxSize + 4;
        // Scale down hatch gap and weight for small legend swatches so the
        // sketch fill remains visually balanced.
        const legendGap = Math.max(1, Math.round(voronoiFillGap / 5));
        const legendWeight = Math.max(0.5, voronoiFillWeight / 5);
        const sw = rc.rectangle(swX, swY, boxSize, boxSize, {
          stroke: 'none',
          strokeWidth: 0,
          fill: color,
          fillStyle: voronoiFillStyle,
          hachureGap: legendGap,
          fillWeight: legendWeight,
          roughness: sketchRoughness,
          bowing: sketchBowing
        });
        sw.classList.add('pot-legend-swatch');
        svg.node().appendChild(sw);
      });
    }

    // Add author and date at the bottom left if they exist
    if (author || date) {
      const metadataY = height - 20; // Position near bottom of SVG
      const metadataText = [author, date].filter(Boolean).join(', ');
      
      svg.append('text')
        .attr('class', 'metadata-text')
        .attr('x', nameX)
        .attr('y', metadataY)
        .attr('font-size', '12px')
        .attr('font-family', 'xkcd Script, cursive')
        .attr('fill', 'var(--text-muted)')
        .text(metadataText);
    }
    
    // Add comment below author/date if it exists
    if (comment) {
      const commentY = (author || date) ? height - 5 : height - 20;
      
      svg.append('text')
        .attr('class', 'metadata-text')
        .attr('x', nameX)
        .attr('y', commentY)
        .attr('font-size', '11px')
        .attr('font-family', 'xkcd Script, cursive')
        .attr('fill', 'var(--text-muted)')
        .text(comment);
    }
  }
  
  // Function to display instructions in top-right quadrant
  function displayInstructions() {
    // No instructions to display, only title
  }

  // Function to update generate button state
  function updateGenerateButtonState() {
    const input = (document.getElementById('recipe-input') as HTMLTextAreaElement).value;
    const button = document.getElementById('generate-flowchart') as HTMLButtonElement;
    const hasContent = input.trim().length > 0;
    
    button.disabled = !hasContent;
    if (!hasContent) {
      button.classList.add('opacity-30', 'cursor-not-allowed');
    } else {
      button.classList.remove('opacity-30', 'cursor-not-allowed');
    }
  }

  // URL encoding/decoding functions using hash fragment for shorter URLs
  function encodeRecipeToURL(recipe: string, positions?: {[hash: string]: {x: number, y: number}}): string {
    const url = new URL(window.location.href);
    
    // Only encode the recipe text - skip positions to keep URLs short
    const encoded = btoa(unescape(encodeURIComponent(recipe)));
    
    // Use hash fragment instead of query params for cleaner URLs
    url.hash = encoded;
    url.search = ''; // Clear any query params
    
    return url.toString();
  }

  function loadRecipeFromURL(): {recipe: string | null, positions: {[hash: string]: {x: number, y: number}} | null} {
    const hash = window.location.hash.slice(1); // Remove #
    
    if (!hash) {
      return { recipe: null, positions: null };
    }
    
    try {
      // Decode base64
      const recipe = decodeURIComponent(escape(atob(hash)));
      
      return {
        recipe: recipe || null,
        positions: null // Don't load positions from URL to keep URLs short
      };
    } catch (e) {
      console.error('Failed to decode URL:', e);
      return { recipe: null, positions: null };
    }
  }

  // Set up button handlers
  const recipeInput = document.getElementById('recipe-input') as HTMLTextAreaElement;
  
  // Load recipe from URL on page load
  const urlData = loadRecipeFromURL();
  if (urlData.recipe) {
    recipeInput.value = urlData.recipe;
    
    // Auto-generate flowchart if recipe is in URL
    setTimeout(() => {
      document.getElementById('generate-flowchart')?.click();
    }, 100);
    // Clear URL hash to keep URL clean
    window.history.replaceState({}, '', window.location.pathname);
  }
  
  // Update button state on input
  recipeInput.addEventListener('input', updateGenerateButtonState);
  
  // Initial button state check
  updateGenerateButtonState();
  
  document.getElementById('generate-flowchart')!.addEventListener('click', () => {
    const input = recipeInput.value;
    if (input.trim()) {
      // Persist positions of the currently rendered graph so hashes are
      // available to match nodes when we regenerate the flowchart.
      try { saveAllPositionsForCurrentGraph(); } catch (e) { }

      const parsed = parseRecipe(input);
      // Set titleOffset based on whether title exists (before initSVG)
      titleOffset = title ? 35 : 0;
      height = baseHeight + titleOffset;
      initSVG();
      let dataToRender = parsed.graphData;
      if (graphStructureEqual(currentData, parsed.graphData)) {
        dataToRender = mergeGraphsPreserveIds(currentData, parsed.graphData);
      }
      renderFlowchart(dataToRender);
      displayIngredients(parsed.ingredients);
      displayInstructions();
    }
  });

  // Helper function to get or fetch the embedded font data URL
  async function getEmbeddedFontDataUrl(): Promise<string> {
    if (cachedFontDataUrl) return cachedFontDataUrl;
    
    try {
      const fontResponse = await fetch('/fonts/xkcd-script.woff');
      const fontBlob = await fontResponse.blob();
      const fontBase64 = await new Promise<string>((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result as string);
        reader.readAsDataURL(fontBlob);
      });
      cachedFontDataUrl = fontBase64;
      return fontBase64;
    } catch (e) {
      console.warn('Failed to embed font, using URL reference:', e);
      return 'url(/fonts/xkcd-script.woff)';
    }
  }

  // Helper function to generate filename from title
  function getFlowchartFilename(extension: string): string {
    const baseFilename = title && title.trim() 
      ? title.trim().toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '') 
      : 'recipe';
    return `${baseFilename}_flowchart.${extension}`;
  }

  document.getElementById('save-svg')!.addEventListener('click', async () => {
    const svgElement = document.querySelector('#recipe-flowchart svg') as SVGSVGElement;
    if (!svgElement) return;

    // Clone the SVG to avoid modifying the original
    const svgClone = svgElement.cloneNode(true) as SVGSVGElement;

    // Get the embedded font data URL (cached after first call)
    const fontDataUrl = await getEmbeddedFontDataUrl();

    // Inject xkcd font-face CSS into SVG with embedded font data
    const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
    style.textContent = `@font-face { font-family: "xkcd Script"; src: url('${fontDataUrl}') format('woff'); font-weight: normal; font-style: normal; } text { font-family: 'xkcd Script', cursive; }`;
    svgClone.insertBefore(style, svgClone.firstChild);

    // Add metadata
    const metadata = document.createElementNS('http://www.w3.org/2000/svg', 'metadata');
    const desc = document.createElementNS('http://www.w3.org/2000/svg', 'desc');
    desc.textContent = 'Created with Recipe to Flowchart - https://thomasvanriel.com/blog/10-recipe-to-flowchart/';
    metadata.appendChild(desc);
    svgClone.insertBefore(metadata, svgClone.firstChild);

    // Get the SVG markup
    const svgData = new XMLSerializer().serializeToString(svgClone);

    // Create a blob and download
    const blob = new Blob([svgData], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = getFlowchartFilename('svg');
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  });
  
  // Helper: rasterize an SVG element into a canvas (returns Promise<HTMLCanvasElement>)
  async function exportSVGToCanvas(svgElement: SVGSVGElement, scale = (window.devicePixelRatio || 1), whiteBackground = false) {
    // Clone to avoid mutating original
    const svgClone = svgElement.cloneNode(true) as SVGSVGElement;

    // Get the embedded font data URL (cached after first call)
    const fontDataUrl = await getEmbeddedFontDataUrl();

    // Inject xkcd font-face CSS into SVG with embedded font data
    const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
    style.textContent = `@font-face { font-family: "xkcd Script"; src: url('${fontDataUrl}') format('woff'); font-weight: normal; font-style: normal; } text { font-family: 'xkcd Script', cursive; }`;
    svgClone.insertBefore(style, svgClone.firstChild);

    // Add metadata
    const metadata = document.createElementNS('http://www.w3.org/2000/svg', 'metadata');
    const desc = document.createElementNS('http://www.w3.org/2000/svg', 'desc');
    desc.textContent = 'Created with Recipe to Flowchart - https://thomasvanriel.com/blog/10-recipe-to-flowchart/';
    metadata.appendChild(desc);
    svgClone.insertBefore(metadata, svgClone.firstChild);

    // Determine intrinsic size from viewBox if available
    const vb = svgElement.viewBox && svgElement.viewBox.baseVal;
    const intrinsicWidth = (vb && vb.width) ? vb.width : (svgElement.clientWidth || width);
    const intrinsicHeight = (vb && vb.height) ? vb.height : (svgElement.clientHeight || height);

    svgClone.setAttribute('width', String(intrinsicWidth));
    svgClone.setAttribute('height', String(intrinsicHeight));

    return new Promise<HTMLCanvasElement>((resolve, reject) => {
      const serialized = new XMLSerializer().serializeToString(svgClone);
      const blob = new Blob([serialized], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const img = new Image();

      img.onload = () => {
        try {
          const canvas = document.createElement('canvas');
          canvas.width = Math.round(intrinsicWidth * scale);
          canvas.height = Math.round(intrinsicHeight * scale);
          const ctx = canvas.getContext('2d');
          if (!ctx) throw new Error('Could not get canvas context');
          // Scale so image renders crisply on high-DPI screens
          ctx.setTransform(scale, 0, 0, scale, 0, 0);
          // Add white background if requested
          if (whiteBackground) {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, intrinsicWidth, intrinsicHeight);
          }
          ctx.drawImage(img, 0, 0);
          URL.revokeObjectURL(url);
          resolve(canvas);
        } catch (err) {
          URL.revokeObjectURL(url);
          reject(err);
        }
      };

      img.onerror = (e) => {
        URL.revokeObjectURL(url);
        reject(e);
      };

      // Use a data URL for CORS-safe rendering when possible
      img.src = url;
    });
  }

  // Download as PNG
  async function downloadPNG(svgElement: SVGSVGElement, whiteBackground = false) {
    try {
      const canvas = await exportSVGToCanvas(svgElement, window.devicePixelRatio || 1, whiteBackground);
      canvas.toBlob((blob) => {
        if (!blob) return;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = getFlowchartFilename('png');
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }, 'image/png');
    } catch (err) {
      // Fallback: download SVG if rasterization fails
      console.error('PNG export failed, falling back to SVG:', err);
      const blob = new Blob([new XMLSerializer().serializeToString(svgElement)], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = getFlowchartFilename('svg');
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }
  }

  

  // Wire up new buttons
  document.getElementById('save-png')!.addEventListener('click', async () => {
    const svgElement = document.querySelector('#recipe-flowchart svg') as SVGSVGElement;
    if (!svgElement) return;
    const transparentBackground = (document.getElementById('png-white-bg') as HTMLInputElement).checked;
    await downloadPNG(svgElement, !transparentBackground);
  });

  // Share button: copy URL with recipe to clipboard
  document.getElementById('share-recipe')!.addEventListener('click', async () => {
    const input = recipeInput.value;
    if (!input.trim()) {
      alert('Please enter a recipe first!');
      return;
    }
    
    const shareUrl = encodeRecipeToURL(input);
    
    try {
      await navigator.clipboard.writeText(shareUrl);
      const btn = document.getElementById('share-recipe')!;
      const originalText = btn.textContent;
      btn.textContent = 'Link copied!';
      setTimeout(() => {
        btn.textContent = originalText;
      }, 2000);
    } catch (err) {
      // Fallback for browsers without clipboard API
      prompt('Copy this link to share your recipe:', shareUrl);
    }
  });
  
  // Pots toggle: hide/show voronoi background and legend
  const togglePotsEl = document.getElementById('toggle-pots') as HTMLInputElement | null;
  if (togglePotsEl) {
    togglePotsEl.addEventListener('change', (e) => {
      showPots = !!(togglePotsEl && togglePotsEl.checked);
      if (!showPots) {
        try {
          // remove any voronoi shapes and legend items
          voronoiGroup.selectAll('.voronoi-rough').remove();
        } catch (err) { }
        svg.selectAll('.pot-legend').remove();
        svg.selectAll('.pot-legend-box').remove();
        svg.selectAll('.pot-legend-swatch').remove();
      } else {
        // Re-render the flowchart (cheap) so Voronoi and legend are recomputed
        try {
          renderFlowchart(currentData);
          displayIngredients(lastIngredients || []);
        } catch (err) { /* non-fatal */ }
      }
    });
  }


  // Theme toggle logic
  const themeButton = document.getElementById('toggle-theme');
  function updateThemeButton() {
    const isDark = document.documentElement.classList.contains('dark');
    themeButton!.textContent = isDark ? 'Switch to Light Mode' : 'Switch to Dark Mode';
    //themeButton!.classList.toggle('bg-gray-800', isDark);
    //themeButton!.classList.toggle('bg-gray-400', !isDark);
    //themeButton!.classList.toggle('text-white', isDark);
    //themeButton!.classList.toggle('text-black', !isDark);
  }
  themeButton?.addEventListener('click', () => {
    document.documentElement.classList.toggle('dark');
    updateThemeButton();
  });
  updateThemeButton();
</script>

<style>
  @font-face {
    font-family: "xkcd Script";
    src: url("/fonts/xkcd-script.woff") format("woff");
    font-weight: normal;
    font-style: normal;
    font-display: swap;
  }

  #recipe-flowchart {
    border: 0px solid #e5e7eb;
    border-radius: 0.5rem;
    background: transparent;
    overflow: hidden;
    
    --arrow-color: #666;
    --link-color: #666;
    --text-color: #1f2937;
    --text-muted: #6b7280;
    --output-fill: rgba(13, 102, 255, 0.5);
  }
  
  #recipe-flowchart text {
    font-family: "xkcd Script", cursive;
  }
  
  :global(.dark) #recipe-flowchart {
    background: transparent;
    
    --arrow-color: #9ca3af;
    --link-color: #9ca3af;
    --node-stroke: #e5e7eb;
    --text-color: #f3f4f6;
    --text-muted: #9ca3af;
    --output-fill: rgba(156, 163, 175, 0.15);
    --border-color: #e5e7eb;
  }
</style>
